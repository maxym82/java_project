/******************************************************************************/
/***          Generated by IBExpert 2018.3.1.1 06.07.2019 12:32:25          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1251;

CREATE DATABASE '..\..\target\db\db.fdb'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 4096
DEFAULT CHARACTER SET WIN1251 COLLATION WIN1251;



/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/

CREATE DOMAIN TBINARY AS
BLOB SUB_TYPE 0 SEGMENT SIZE 80;

CREATE DOMAIN TBOOLEAN AS
INTEGER
CHECK (value in (1,0));

CREATE DOMAIN TCHAR AS
VARCHAR(1);

CREATE DOMAIN TCOUNT AS
INTEGER;

CREATE DOMAIN TDATE AS
DATE;

CREATE DOMAIN TDATETIME AS
TIMESTAMP;

CREATE DOMAIN TDATETIME_VARCHAR AS
VARCHAR(24);

CREATE DOMAIN TDB_CODE AS
INTEGER
CHECK (char_length(value) <= 4);

CREATE DOMAIN TDESCRIPTION AS
VARCHAR(4096);

CREATE DOMAIN THASH AS
BIGINT;

CREATE DOMAIN TID AS
INTEGER;

CREATE DOMAIN TLONG_DESCRIPTION AS
VARCHAR(32000);

CREATE DOMAIN TLONG_NAME AS
VARCHAR(512);

CREATE DOMAIN TMIDDLE_DESCRIPTION AS
VARCHAR(16000);

CREATE DOMAIN TNAME AS
VARCHAR(64);

CREATE DOMAIN TPERCENT AS
DOUBLE PRECISION
DEFAULT 0
CHECK (value >= 0 and value <= 100);

CREATE DOMAIN TQUANTITY AS
DOUBLE PRECISION
CHECK (value >= 0);

CREATE DOMAIN TSERVER_USER AS
VARCHAR(31);

CREATE DOMAIN TSHORT_DESCRIPTION AS
VARCHAR(1024);

CREATE DOMAIN TSHORT_NAME AS
VARCHAR(16);

CREATE DOMAIN TTEXT AS
BLOB SUB_TYPE 1 SEGMENT SIZE 80;

CREATE DOMAIN TVERY_SHORT_NAME AS
VARCHAR(8);



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_APP$BANS_ID;
SET GENERATOR GEN_APP$BANS_ID TO 4138;

CREATE GENERATOR GEN_APP$EXCEPTION_ID;
SET GENERATOR GEN_APP$EXCEPTION_ID TO 211;

CREATE GENERATOR GEN_APP$KEY_ID;
SET GENERATOR GEN_APP$KEY_ID TO 3850;

CREATE GENERATOR GEN_APP$NEW_UPDATE_ID;
SET GENERATOR GEN_APP$NEW_UPDATE_ID TO 128;

CREATE GENERATOR GEN_APP$PARAMETER_ID;
SET GENERATOR GEN_APP$PARAMETER_ID TO 872;

CREATE GENERATOR GEN_APP$REPORTS_HTML_ID;
SET GENERATOR GEN_APP$REPORTS_HTML_ID TO 3888;

CREATE GENERATOR GEN_APP$REPORTS_ID;
SET GENERATOR GEN_APP$REPORTS_ID TO 2168;

CREATE GENERATOR GEN_APP$REPORTS_PARAMETER_ID;
SET GENERATOR GEN_APP$REPORTS_PARAMETER_ID TO 600;

CREATE GENERATOR GEN_APP$ROLES_ID;
SET GENERATOR GEN_APP$ROLES_ID TO 203;

CREATE GENERATOR GEN_APP$UPDATE_ID;
SET GENERATOR GEN_APP$UPDATE_ID TO 17;

CREATE GENERATOR GEN_APP$USERS_ID;
SET GENERATOR GEN_APP$USERS_ID TO 125;

CREATE GENERATOR GEN_APPLICATION_ID;
SET GENERATOR GEN_APPLICATION_ID TO 1653;

CREATE GENERATOR GEN_APPLICATION_STATUS_ID;
SET GENERATOR GEN_APPLICATION_STATUS_ID TO 7;

CREATE GENERATOR GEN_CHECK_RESULT_ID;
SET GENERATOR GEN_CHECK_RESULT_ID TO 21;

CREATE GENERATOR GEN_CONFIG__ID;
SET GENERATOR GEN_CONFIG__ID TO 3;

CREATE GENERATOR GEN_CUSTOMER_DEBT_ID;
SET GENERATOR GEN_CUSTOMER_DEBT_ID TO 51858;

CREATE GENERATOR GEN_DEPARTMENT_ID;
SET GENERATOR GEN_DEPARTMENT_ID TO 6;

CREATE GENERATOR GEN_DESCRIPTION_TYPE_WORK_ID;
SET GENERATOR GEN_DESCRIPTION_TYPE_WORK_ID TO 14;

CREATE GENERATOR GEN_EMPLOYEES_ID;
SET GENERATOR GEN_EMPLOYEES_ID TO 5742;

CREATE GENERATOR GEN_EXPELLED_ID;
SET GENERATOR GEN_EXPELLED_ID TO 14;

CREATE GENERATOR GEN_FOUNDERS_ID;
SET GENERATOR GEN_FOUNDERS_ID TO 1586;

CREATE GENERATOR GEN_FUND_SUM_CONTRACT_ID;
SET GENERATOR GEN_FUND_SUM_CONTRACT_ID TO 17;

CREATE GENERATOR GEN_FUND_SUM_HARM_ID;
SET GENERATOR GEN_FUND_SUM_HARM_ID TO 11;

CREATE GENERATOR GEN_GROUP_TYPE_WORK_ID;
SET GENERATOR GEN_GROUP_TYPE_WORK_ID TO 8303;

CREATE GENERATOR GEN_INFRINGEMENTS_ID;
SET GENERATOR GEN_INFRINGEMENTS_ID TO 16;

CREATE GENERATOR GEN_INSURANCE_ID;
SET GENERATOR GEN_INSURANCE_ID TO 445;

CREATE GENERATOR GEN_INSURANCE_SUBJECT_ID;
SET GENERATOR GEN_INSURANCE_SUBJECT_ID TO 4;

CREATE GENERATOR GEN_INTERVENTION_ID;
SET GENERATOR GEN_INTERVENTION_ID TO 1229;

CREATE GENERATOR GEN_LEGAL_FORM_ID;
SET GENERATOR GEN_LEGAL_FORM_ID TO 16;

CREATE GENERATOR GEN_LEVEL_CONTRACTOR_ID;
SET GENERATOR GEN_LEVEL_CONTRACTOR_ID TO 5;

CREATE GENERATOR GEN_LEVEL_HARM_ID;
SET GENERATOR GEN_LEVEL_HARM_ID TO 5;

CREATE GENERATOR GEN_LIMIT_ID;
SET GENERATOR GEN_LIMIT_ID TO 12;

CREATE GENERATOR GEN_MEASURE_ID;
SET GENERATOR GEN_MEASURE_ID TO 27;

CREATE GENERATOR GEN_ORGANIZATION_HISTORY_ID;
SET GENERATOR GEN_ORGANIZATION_HISTORY_ID TO 1462;

CREATE GENERATOR GEN_ORGANIZATION_ID;
SET GENERATOR GEN_ORGANIZATION_ID TO 1299;

CREATE GENERATOR GEN_ORGANIZATION_INSURANCE_ID;
SET GENERATOR GEN_ORGANIZATION_INSURANCE_ID TO 4139;

CREATE GENERATOR GEN_ORGANIZATION_ISSUE_ID;
SET GENERATOR GEN_ORGANIZATION_ISSUE_ID TO 89;

CREATE GENERATOR GEN_PERILOUS_ID;
SET GENERATOR GEN_PERILOUS_ID TO 10;

CREATE GENERATOR GEN_PERSON_ID;
SET GENERATOR GEN_PERSON_ID TO 1985;

CREATE GENERATOR GEN_PROTOCOL_ID;
SET GENERATOR GEN_PROTOCOL_ID TO 579;

CREATE GENERATOR GEN_REGION_ID;
SET GENERATOR GEN_REGION_ID TO 103;

CREATE GENERATOR GEN_REGISTER_CHECK_ID;
SET GENERATOR GEN_REGISTER_CHECK_ID TO 2970;

CREATE GENERATOR GEN_REGISTER_CODE;
SET GENERATOR GEN_REGISTER_CODE TO 1237;

CREATE GENERATOR GEN_REGISTER_ID;
SET GENERATOR GEN_REGISTER_ID TO 1280;

CREATE GENERATOR GEN_RIGHT__ID;
SET GENERATOR GEN_RIGHT__ID TO 1297;

CREATE GENERATOR GEN_SCOPE_WORK_ID;
SET GENERATOR GEN_SCOPE_WORK_ID TO 9;

CREATE GENERATOR GEN_TYPE_CHECK_ID;
SET GENERATOR GEN_TYPE_CHECK_ID TO 4;

CREATE GENERATOR GEN_TYPE_WORK_ID;
SET GENERATOR GEN_TYPE_WORK_ID TO 2232;

CREATE GENERATOR GEN_VERIFICATION_ID;
SET GENERATOR GEN_VERIFICATION_ID TO 87;



/******************************************************************************/
/***                           Stored procedures                            ***/
/******************************************************************************/



SET TERM ^ ;

CREATE PROCEDURE BASE$CHANGE_CASE (
    FIO TLONG_NAME)
RETURNS (
    NAME TLONG_NAME,
    SNAME TLONG_NAME,
    PNAME TLONG_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE BASE$EXECUTE_STATEMENT (
    SQL TDESCRIPTION)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE BASE$FIRST_LAST_DAY_IN_MONTH (
    DATE_ DATE)
RETURNS (
    FIRST_DAY DATE,
    LAST_DAY DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE BASE$FOR_INT (
    FINISH_VALUE TID,
    START_VALUE TID = 0)
RETURNS (
    I TID)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CONFIG (
    DATE_NOW TDATE = '01.01.2100')
RETURNS (
    ID_CONFIG TID,
    DATE_ TDATE,
    LONG_NAME TLONG_NAME,
    LONG_NAME2 TLONG_NAME,
    SHORT_NAME TNAME,
    NAME TLONG_NAME,
    CODE TNAME,
    NUMBER TID,
    ADDRESS TDESCRIPTION,
    SHORT_ADDRESS TLONG_NAME,
    PHONE TNAME,
    COUNT_BANK TNAME,
    INN TNAME,
    KPP TNAME,
    BANK_NAME TDESCRIPTION,
    BANK_BIK TNAME,
    BANK_COUNT TNAME,
    COUNT_NUMBER_ TID,
    ID_APPLICATION_STATUS_RESET TID,
    EMAIL TLONG_NAME,
    ID_PERILOUS TID,
    ID_APPLICATION_STATUS_END TID,
    ID_APPLICATION_STATUS_ACTIVE TID,
    ID_APPLICATION_STATUS_SUSPENDED TID,
    ID_REGION TID)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE DATA_GET_NUMBER (
    CODE TID,
    DATE_ TDATE)
RETURNS (
    NUMBER TLONG_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE DATE_TIME_TO_STR (
    DATE_TIME TDATETIME,
    FORMAT TDATETIME_VARCHAR = 'DD.MM.YYYY HH:NN:SS.ZZZ')
RETURNS (
    RESULT TDATETIME_VARCHAR)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE DELETE_REGISTER
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE FLOAT_TO_STR (
    FLOAT_ TQUANTITY,
    DIGITS TID = 2)
RETURNS (
    RESULT TSHORT_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_CURRENCYSTR (
    VAL NUMERIC(15,2),
    SHOWCURRENCY INTEGER = 1)
RETURNS (
    RESULT TSHORT_DESCRIPTION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_INDEX_LIST (
    SQL TDESCRIPTION)
RETURNS (
    INDEX_ TID,
    ID TID,
    NAME TLONG_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_REGISTER_HASH (
    ALL_REGISTER TBOOLEAN = 0,
    UPDATE_REGISTER TBOOLEAN = 1)
RETURNS (
    ID_REGISTER TID)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_TREE (
    PARENT_VALUE TID,
    TABLE_NAME TNAME NOT NULL,
    FIELD_ID TNAME NOT NULL,
    FIELD_NAME TNAME NOT NULL,
    FIELD_PARENT TNAME NOT NULL,
    FIELD_ORDER TNAME,
    PREFIX TNAME NOT NULL)
RETURNS (
    ID TID,
    NAME TLONG_NAME,
    PARENT TID)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_WORD (
    STR TDESCRIPTION,
    SEPARATOR TVERY_SHORT_NAME = ',',
    INDEX_ TID = 1)
RETURNS (
    WORD TLONG_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE LAST_APPLICATION (
    REG_CODE TID,
    DATE_ TDATE = '01.01.2100')
RETURNS (
    ID_APPLICATION TID,
    CREATE_DATE TDATE,
    DECISION_DATE TDATE,
    NUMBER TSHORT_NAME,
    ID_ORGANIZATION_ TID,
    ID_PROTOCOL TID,
    CERTIFICATE TLONG_NAME,
    ID_APPLICATION_STATUS TID,
    STATUS_DATE TDATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE LAST_RIGHT (
    REG_CODE TID,
    DATE_ TDATE = '01.01.2100')
RETURNS (
    ID_RIGHT TID,
    DECISION_DATE TDATE,
    NUMBER TSHORT_NAME,
    ID_ORGANIZATION_ TID,
    ID_PROTOCOL TID,
    ID_PERILOUS TID,
    ID_APPLICATION_STATUS TID)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE LAST_STATUS (
    CODE TID)
RETURNS (
    ID_PROTOCOL TID,
    NUMBER TSHORT_NAME,
    DECISION_DATE TDATE,
    ID_APPLICATION_STATUS TID,
    ID_PERILOUS TID,
    PERILOUS_INDEX TID)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE MONTH_LIST (
    END_ TID = 1,
    SELECT_ TID = 0)
RETURNS (
    INDEX_ TID,
    NAME_ TNAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NAME_TO_FIELDS (
    NAME TLONG_NAME)
RETURNS (
    L_NAME TLONG_NAME,
    F_NAME TLONG_NAME,
    M_NAME TLONG_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NAME_TO_SHORT (
    NAME TLONG_NAME,
    SNAME TLONG_NAME,
    PNAME TLONG_NAME)
RETURNS (
    RESULT TLONG_NAME)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NUMBERS_FROM_STRING (
    STR TSHORT_DESCRIPTION)
RETURNS (
    RESULT TQUANTITY)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SENTENCE_TO_TABLE (
    STR TDESCRIPTION,
    SEPARATOR TVERY_SHORT_NAME = ',')
RETURNS (
    WORD TLONG_NAME,
    INDEX_ INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SET_CONFIG_COUNT_NUMBER_ (
    COUNT_NUMBER_ INTEGER)
RETURNS (
    NEW_COUNT_NUMBER_ INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE STR_TO_JSON (
    STR TMIDDLE_DESCRIPTION)
RETURNS (
    RESULT TMIDDLE_DESCRIPTION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE STR_TO_XML (
    STR TMIDDLE_DESCRIPTION)
RETURNS (
    RESULT TMIDDLE_DESCRIPTION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE USER$CUSTOMER_DEBT (
    LINE TLONG_DESCRIPTION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE USER$GET_NOSTROY_PACKAGE (
    CODE TID = null,
    UPDATE_RECORD TBOOLEAN = 0)
RETURNS (
    ID_REGISTER TID,
    XML TLONG_DESCRIPTION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE USER$REFRESH_NOSTROY_STATUS
RETURNS (
    ID_REGISTER TID,
    CODE TID,
    NAME TSHORT_DESCRIPTION)
AS
BEGIN
  SUSPEND;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE APP$BANS (
    ID_BANS      TID NOT NULL,
    FORM         TNAME NOT NULL,
    ACTION_NAME  TNAME NOT NULL,
    CAPTION      TLONG_NAME,
    ID_ROLES     TID NOT NULL,
    DETAILS      TDESCRIPTION
);

CREATE TABLE APP$EXCEPTION (
    ID_EXCEPTION  TID NOT NULL,
    EXCEPTION_    TLONG_NAME NOT NULL,
    TEXT          TLONG_NAME
);

CREATE TABLE APP$KEY (
    ID_KEY  TID NOT NULL,
    NAME    TLONG_NAME NOT NULL,
    KEY_    TLONG_NAME NOT NULL,
    VALUE_  TMIDDLE_DESCRIPTION,
    USER_   TNAME NOT NULL
);

CREATE TABLE APP$NEW_UPDATE (
    ID_NEW_UPDATE  TID NOT NULL,
    DATE_TIME      TDATETIME NOT NULL,
    DESCRIPTION    TSHORT_DESCRIPTION
);

CREATE TABLE APP$PARAMETER (
    ID_PARAMETER  TID NOT NULL,
    CLASS         TNAME NOT NULL,
    PARAMETER_    TDESCRIPTION,
    INDEX_        TID NOT NULL,
    REPORTS_ID    TID NOT NULL
);

CREATE TABLE APP$REPORTS (
    ID_REPORTS     TID NOT NULL,
    CAPTION        TLONG_NAME,
    DESCRIPTION    TLONG_NAME,
    REPORT_NAME    TLONG_NAME,
    TYPE_          TID NOT NULL,
    PARENT_REPORT  TID,
    INDEX_         TID NOT NULL,
    PARAMETER_     TDESCRIPTION
);

CREATE TABLE APP$REPORTS_HTML (
    ID_REPORTS_HTML  TID NOT NULL,
    NAME             TNAME,
    SQL              TLONG_DESCRIPTION,
    TEXT             TLONG_DESCRIPTION,
    PARENT_ID        TID,
    INDEX_           TID NOT NULL,
    REPORTS_ID       TID NOT NULL
);

CREATE TABLE APP$REPORTS_PARAMETER (
    ID_REPORTS_PARAMETER  TID NOT NULL,
    REPORT_NAME           TNAME NOT NULL,
    LIST_NAME             TNAME NOT NULL,
    REPORTS_ID            TID NOT NULL
);

CREATE TABLE APP$ROLES (
    ID_ROLES     TID NOT NULL,
    NAME         TNAME NOT NULL,
    DESCRIPTION  TLONG_NAME
);

CREATE TABLE APP$UPDATE (
    ID_UPDATE  TID NOT NULL,
    FILE_NAME  TLONG_NAME NOT NULL,
    DATE_TIME  TDATETIME NOT NULL,
    DATA       TBINARY
);

CREATE TABLE APP$UPDATE_NEW (
    ID_UPDATE      TID NOT NULL,
    ID_NEW_UPDATE  TID NOT NULL,
    INDEX_         TID NOT NULL
);

CREATE TABLE APP$USERS (
    ID_USERS     TID NOT NULL,
    SERVER_USER  TSHORT_NAME NOT NULL,
    ALIAS        TNAME NOT NULL,
    FNP          TLONG_NAME NOT NULL,
    PERMISSION   TBOOLEAN NOT NULL,
    ID_ROLES     TID NOT NULL
);

CREATE TABLE APPLICATION (
    ID_APPLICATION             TID NOT NULL,
    CREATE_DATE                TDATE NOT NULL,
    ID_REGISTER                TID NOT NULL,
    ID_PROTOCOL                TID,
    CERTIFICATE                TLONG_NAME,
    ID_APPLICATION_STATUS      TID,
    STATUS_DATE                TDATE,
    ID_LIMIT                   TID,
    ID_ORGANIZATION_INSURANCE  TID
);

CREATE TABLE APPLICATION_STATUS (
    ID_APPLICATION_STATUS  TID NOT NULL,
    CODE                   TID NOT NULL,
    NAME                   TLONG_NAME NOT NULL
);

CREATE TABLE APPLICATION_TYPE_WORK (
    ID_APPLICATION  TID NOT NULL,
    ID_TYPE_WORK    TID NOT NULL,
    ALLOWED         TBOOLEAN DEFAULT 0 NOT NULL,
    ID_PERILOUS     TID,
    ID_DESCRIPTION  TID,
    ID_LIMIT        TID
);

CREATE TABLE CHECK_RESULT (
    ID_CHECK_RESULT  TID NOT NULL,
    NAME             TLONG_NAME NOT NULL,
    DESCRIPTION      TSHORT_DESCRIPTION,
    IS_VIOLATIONS    TBOOLEAN NOT NULL
);

CREATE TABLE CONFIG_ (
    ID_CONFIG                        TID NOT NULL,
    DATE_                            TDATE NOT NULL,
    LONG_NAME                        TLONG_NAME NOT NULL,
    LONG_NAME2                       TLONG_NAME NOT NULL,
    SHORT_NAME                       TNAME NOT NULL,
    NAME                             TLONG_NAME NOT NULL,
    CODE                             TNAME NOT NULL,
    NUMBER                           TID NOT NULL,
    ADDRESS                          TDESCRIPTION NOT NULL,
    SHORT_ADDRESS                    TLONG_NAME NOT NULL,
    PHONE                            TNAME NOT NULL,
    COUNT_BANK                       TNAME NOT NULL,
    INN                              TNAME NOT NULL,
    KPP                              TNAME NOT NULL,
    BANK_NAME                        TDESCRIPTION NOT NULL,
    BANK_BIK                         TNAME NOT NULL,
    BANK_COUNT                       TNAME NOT NULL,
    COUNT_NUMBER_                    TID,
    ID_APPLICATION_STATUS_RESET      TID NOT NULL,
    EMAIL                            TLONG_NAME NOT NULL,
    ID_PERILOUS                      TID,
    ID_APPLICATION_STATUS_END        TID NOT NULL,
    ID_APPLICATION_STATUS_ACTIVE     TID NOT NULL,
    ID_APPLICATION_STATUS_SUSPENDED  TID NOT NULL,
    ID_REGION                        TID NOT NULL
);

CREATE TABLE CUSTOMER_DEBT (
    ID_CUSTOMER_DEBT  TID NOT NULL,
    ID_REGISTER       INTEGER NOT NULL,
    INDEX_            TID NOT NULL,
    VALUE_            TCOUNT NOT NULL
);

CREATE TABLE DEPARTMENT (
    ID_DEPARTMENT  TID NOT NULL,
    NAME           TNAME NOT NULL,
    SHORT_NAME     TNAME,
    DESCRIPTION    TSHORT_DESCRIPTION
);

CREATE TABLE DESCRIPTION_TYPE_WORK (
    ID_DESCRIPTION_TYPE_WORK  TID NOT NULL,
    DESCRIPTION               TLONG_NAME NOT NULL,
    ID_LIMIT                  TID
);

CREATE TABLE EMPLOYEES (
    ID_EMPLOYEES      TID NOT NULL,
    NAME              TLONG_NAME NOT NULL,
    NUMBER            TNAME,
    DESCRIPTION       TDESCRIPTION,
    ID_ORGANIZATION_  TID NOT NULL
);

CREATE TABLE EXPELLED (
    ID_EXPELLED  TID NOT NULL,
    NAME         TLONG_NAME NOT NULL
);

CREATE TABLE FOUNDERS (
    ID_FOUNDERS        TID NOT NULL,
    ID_ORGANIZATION_   TID NOT NULL,
    SHARE_CAPITAL      TPERCENT NOT NULL,
    ID_PERSON          TID,
    ID_ORGANIZATION__  TID
);

CREATE TABLE FUND_SUM_CONTRACT (
    ID_FUND_SUM_CONTRACT  TID NOT NULL,
    SUM_                  TQUANTITY NOT NULL
);

CREATE TABLE FUND_SUM_HARM (
    ID_FUND_SUM_HARM  TID NOT NULL,
    SUM_              TQUANTITY NOT NULL
);

CREATE TABLE GROUP_TYPE_WORK (
    ID_GROUP_TYPE_WORK  TID NOT NULL,
    CODE                TVERY_SHORT_NAME NOT NULL,
    NAME                TSHORT_DESCRIPTION NOT NULL,
    ORDER_              TNAME NOT NULL,
    INVISIBLE           TBOOLEAN NOT NULL
);

CREATE TABLE INFRINGEMENTS (
    ID_INFRINGEMENTS  TID NOT NULL,
    NAME              TNAME NOT NULL,
    DESCRIPTION       TSHORT_DESCRIPTION
);

CREATE TABLE INSURANCE (
    ID_INSURANCE  TID NOT NULL,
    NUMBER        TNAME NOT NULL,
    NAME          TLONG_NAME NOT NULL,
    ADDRESS       TDESCRIPTION,
    PHONE         TNAME
);

CREATE TABLE INSURANCE_SUBJECT (
    ID_INSURANCE_SUBJECT  TID NOT NULL,
    CODE                  TID NOT NULL,
    NAME                  TLONG_NAME NOT NULL
);

CREATE TABLE INSURANCE_TYPE_WORK (
    ID_ORGANIZATION_INSURANCE  TID NOT NULL,
    ID_TYPE_WORK               TID NOT NULL
);

CREATE TABLE INTERVENTION (
    ID_INTERVENTION  TID NOT NULL,
    ID_REGISTER      TID NOT NULL,
    DATE_            TDATE,
    NUMBER           TSHORT_NAME,
    DESCRIPTION      TDESCRIPTION,
    ID_DEPARTMENT    TID NOT NULL,
    ID_MEASURE       TID NOT NULL,
    ACTING           TBOOLEAN NOT NULL
);

CREATE TABLE LEGAL_FORM (
    ID_LEGAL_FORM  TID NOT NULL,
    SHORT_NAME     TSHORT_NAME NOT NULL,
    LONG_NAME      TLONG_NAME NOT NULL,
    DESCRIPTION    TDESCRIPTION
);

CREATE TABLE LEVEL_CONTRACTOR (
    ID_LEVEL_CONTRACTOR  TID NOT NULL,
    NAME                 TNAME NOT NULL
);

CREATE TABLE LEVEL_HARM (
    ID_LEVEL_HARM  TID NOT NULL,
    NAME           TNAME NOT NULL
);

CREATE TABLE LIMIT (
    ID_LIMIT       TID NOT NULL,
    NAME           TNAME NOT NULL,
    DESCRIPTION    TDESCRIPTION NOT NULL,
    INSURANCE_SUM  TCOUNT NOT NULL
);

CREATE TABLE MEASURE (
    ID_MEASURE   TID NOT NULL,
    NAME         TNAME NOT NULL,
    DESCRIPTION  TSHORT_DESCRIPTION,
    TYPE_        TCOUNT DEFAULT 0 NOT NULL
);

CREATE TABLE ORGANIZATION_ (
    ID_ORGANIZATION_       TID NOT NULL,
    ID_LEGAL_FORM          TID NOT NULL,
    ID_ORGANIZATION_ISSUE  TID NOT NULL,
    NAME                   TLONG_NAME NOT NULL,
    SHORT_NAME             TLONG_NAME,
    ADDRESS                TDESCRIPTION NOT NULL,
    ADDRESS_INDEX          TVERY_SHORT_NAME NOT NULL,
    ADDRESS_COUNTRY        TNAME NOT NULL,
    ADDRESS_DISTRICT       TNAME,
    ADDRESS_CITY           TNAME,
    ADDRESS_AREA           TNAME,
    ADDRESS_STREET         TNAME,
    ADDRESS_HOUSE          TSHORT_NAME,
    ADDRESS_STRUCTURE      TNAME,
    ADDRESS_ROOM           TSHORT_NAME,
    ADDRESS_DESCRIPTION    TDESCRIPTION,
    OGRN_                  TSHORT_NAME NOT NULL,
    INN_                   TSHORT_NAME NOT NULL,
    ENTRY_DATE             TDATE NOT NULL,
    PHONE                  TNAME NOT NULL,
    FAX                    TNAME,
    ID_PERSON              TID NOT NULL,
    SHARE_CAPITAL          TQUANTITY,
    LICENSE                TNAME,
    ACCOUNTANT_PHONE       TSHORT_NAME,
    ACCOUNTANT             TLONG_NAME,
    BIRTH_DATE             TDATE,
    EMAIL                  TNAME,
    POSITION_HEAD          TNAME,
    ID_REGION              TID NOT NULL
);

CREATE TABLE ORGANIZATION_HISTORY (
    ID_ORGANIZATION_HISTORY  TID NOT NULL,
    ID_ORGANIZATION_         TID NOT NULL,
    ID_LEGAL_FORM            TID NOT NULL,
    ID_ORGANIZATION_ISSUE    TID NOT NULL,
    NAME                     TLONG_NAME NOT NULL,
    SHORT_NAME               TLONG_NAME,
    ADDRESS                  TDESCRIPTION NOT NULL,
    ADDRESS_DESCRIPTION      TDESCRIPTION,
    OGRN_                    TSHORT_NAME NOT NULL,
    INN_                     TSHORT_NAME NOT NULL,
    ENTRY_DATE               TDATE NOT NULL,
    PHONE                    TNAME NOT NULL,
    FAX                      TNAME,
    ID_PERSON                TID NOT NULL,
    SHARE_CAPITAL            TQUANTITY,
    LICENSE                  TNAME,
    ACCOUNTANT_PHONE         TSHORT_NAME,
    ACCOUNTANT               TLONG_NAME,
    BIRTH_DATE               TDATE,
    EMAIL                    TNAME,
    DATE_                    TDATETIME NOT NULL
);

CREATE TABLE ORGANIZATION_INSURANCE (
    ID_ORGANIZATION_INSURANCE  TID NOT NULL,
    ID_ORGANIZATION_           TID NOT NULL,
    ID_INSURANCE               TID NOT NULL,
    ID_SCOPE_WORK              TID,
    ID_INSURANCE_SUBJECT       TID,
    SUM_                       TQUANTITY NOT NULL,
    PREMIUM                    TQUANTITY NOT NULL,
    DATE_START                 TDATE NOT NULL,
    DATE_FINISH                TDATE NOT NULL,
    RETROACTIVE_PERIOD         TLONG_NAME,
    ADDITION                   TBOOLEAN NOT NULL,
    DOC_NUMBER                 TNAME,
    PERIOD_DATE_START          TDATE,
    PERIOD_DATE_FINISH         TDATE,
    DATE_OF_CONTRACT           TDATE
);

CREATE TABLE ORGANIZATION_ISSUE (
    ID_ORGANIZATION_ISSUE  TID NOT NULL,
    NAME                   TSHORT_DESCRIPTION NOT NULL
);

CREATE TABLE PERILOUS (
    ID_PERILOUS  TID NOT NULL,
    NAME         TLONG_NAME NOT NULL,
    INDEX_       TID NOT NULL,
    CAPTION      TNAME
);

CREATE TABLE PERSON (
    ID_PERSON        TID NOT NULL,
    NAME             TLONG_NAME NOT NULL,
    SNAME            TLONG_NAME NOT NULL,
    PNAME            TLONG_NAME NOT NULL,
    PHONE            TSHORT_NAME,
    PASS_ISSUE       TLONG_NAME NOT NULL,
    PASS_ISSUE_CODE  TVERY_SHORT_NAME,
    PASS_DATE        TDATE NOT NULL,
    PASS_SERIES      TVERY_SHORT_NAME NOT NULL,
    PASS_NUMBER      TSERVER_USER NOT NULL,
    PASS_ARRDESS     TLONG_NAME NOT NULL,
    BIRTH_DATE       TDATE,
    BIRTH_PLACE      TLONG_NAME
);

CREATE TABLE PROTOCOL (
    ID_PROTOCOL    TID NOT NULL,
    NUMBER         TSHORT_NAME NOT NULL,
    DECISION_DATE  TDATE NOT NULL
);

CREATE TABLE REGION (
    ID_REGION  TID NOT NULL,
    NAME       TLONG_NAME NOT NULL,
    CODE       TID NOT NULL
);

CREATE TABLE REGISTER (
    ID_REGISTER             TID NOT NULL,
    CODE                    TID,
    ID_ORGANIZATION_        TID NOT NULL,
    MEMBER                  TBOOLEAN DEFAULT 0 NOT NULL,
    HASH_                   TNAME,
    DESCRIPTION             TDESCRIPTION,
    REGISTRATION_DATE       TDATE,
    REGISTRATION_NUMBER     TNAME,
    FUND_SUM                TQUANTITY,
    CORRECT_MEMBER          TBOOLEAN,
    ID_APPLICATION          TID,
    BASE_EXCEPTION          TLONG_NAME,
    ID_EXPELLED             TID,
    ID_FUND_LEVEL_HARM      TID,
    ID_FUND_SUM_HARM        TID,
    ID_FUND_LEVEL_CONTRACT  TID,
    ID_FUND_SUM_CONTRACT    TID,
    EXPELLED_DATE           TDATE,
    EXPELLED_NUMBER         TNAME,
    ID_RIGHT                TID,
    DATE_INSPECTION         TLONG_NAME,
    DID_SEND_TO_NOSTROY     TBOOLEAN DEFAULT 0 NOT NULL,
    NOSTROY_HASH_           THASH DEFAULT 0 NOT NULL
);

CREATE TABLE REGISTER_CHECK (
    ID_REGISTER_CHECK  TID NOT NULL,
    ID_REGISTER        TID NOT NULL,
    ID_TYPE_CHECK      TID NOT NULL,
    ID_CHECK_RESULT    TID NOT NULL,
    DATE_              TDATE NOT NULL,
    ACTING             TBOOLEAN NOT NULL,
    IS_INTERVENTION    TBOOLEAN NOT NULL
);

CREATE TABLE RIGHT_ (
    ID_RIGHT                TID NOT NULL,
    ID_REGISTER             TID NOT NULL,
    ID_PROTOCOL             TID NOT NULL,
    ID_PROTOCOL_CONTRACT    TID,
    ID_APPLICATION_STATUS   TID NOT NULL,
    ID_PERILOUS             TID NOT NULL,
    ID_FUND_LEVEL_HARM      TID,
    ID_FUND_LEVEL_CONTRACT  TID
);

CREATE TABLE SCOPE_WORK (
    ID_SCOPE_WORK  TID NOT NULL,
    NAME           TNAME NOT NULL,
    DESCRIPTION    TDESCRIPTION,
    INDEX_         TID NOT NULL
);

CREATE TABLE TYPE_CHECK (
    ID_TYPE_CHECK  TID NOT NULL,
    NAME           TNAME NOT NULL,
    DESCRIPTION    TSHORT_DESCRIPTION
);

CREATE TABLE TYPE_WORK (
    ID_TYPE_WORK        TID NOT NULL,
    CODE                TVERY_SHORT_NAME NOT NULL,
    NAME                TSHORT_DESCRIPTION NOT NULL,
    ID_GROUP_TYPE_WORK  TID NOT NULL,
    ID_PERILOUS         TID NOT NULL,
    ORDER_              TNAME NOT NULL
);

CREATE TABLE VERIFICATION (
    ID_VERIFICATION          TID NOT NULL,
    ID_REGISTER              TID NOT NULL,
    ORDER_DATE               TDATE NOT NULL,
    ORDER_NUMBER             TSHORT_NAME,
    ORDER_PERIOD_START       TDATE,
    ORDER_PERIOD_FINISH      TDATE,
    AKT_DATE                 TDATE,
    AKT_NUMBER               TSHORT_NAME,
    INSTRUCTION_DATE         TDATE,
    INSTRUCTION_NUMBER       TSHORT_NAME,
    INSTRUCTION_FINISH_DATE  TDATE,
    INSTRUCTION_FINISH       TLONG_NAME,
    COMMISSION_DATE          TDATE,
    COMMISSION_NUMBER        TSHORT_NAME,
    ID_MEASURE               TID,
    DESCRIPTION              TDESCRIPTION
);

CREATE TABLE VERIFICATION_INFRINGEMENTS (
    ID_VERIFICATION   TID NOT NULL,
    ID_INFRINGEMENTS  TID NOT NULL,
    DESCRIPTION       TDESCRIPTION
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: APPLICATION_INSURANCE */
CREATE VIEW APPLICATION_INSURANCE(
    ID_APPLICATION,
    INSURANCE_CALC_SUM)
AS
with
    APPLICATION_ as (
      select A.ID_APPLICATION, OI.ID_SCOPE_WORK,
        count(iif(TW.ID_GROUP_TYPE_WORK not in (3200, 3300), 1, null)) as TW_COUNT,
        iif(count(iif((TW.ID_GROUP_TYPE_WORK not in (3200, 3300)) and ((mod(P.INDEX_, 10) - 1) > 0), 1, null)) > 0, 2, 1) as TW_COUNT_MULTI,

        iif(count(iif(TW.ID_GROUP_TYPE_WORK in (3200), 1, null)) > 0, 2000000, 0) as TW_32,
        iif(count(iif((TW.ID_GROUP_TYPE_WORK in (3200)) and ((mod(P.INDEX_, 10) - 1) > 0), 1, null)) > 0, 2, 1) as TW_32_MULTI,

        iif(count(iif(TW.ID_GROUP_TYPE_WORK in (3300), 1, null)) > 0, max(L.INSURANCE_SUM), 0) as TW_33,
        iif(count(iif((TW.ID_GROUP_TYPE_WORK in (3300)) and ((mod(P.INDEX_, 10) - 1) > 0), 1, null)) > 0, 2, 1) as TW_33_MULTI
      from APPLICATION A
      left join ORGANIZATION_INSURANCE OI on OI.ID_ORGANIZATION_INSURANCE = A.ID_ORGANIZATION_INSURANCE
      left join APPLICATION_TYPE_WORK ATW on ATW.ID_APPLICATION = A.ID_APPLICATION
      left join TYPE_WORK TW on TW.ID_TYPE_WORK = ATW.ID_TYPE_WORK
      left join PERILOUS P on P.ID_PERILOUS = ATW.ID_PERILOUS
      left join DESCRIPTION_TYPE_WORK DTW on DTW.ID_DESCRIPTION_TYPE_WORK = ATW.ID_DESCRIPTION
      left join LIMIT L on (L.ID_LIMIT = ATW.ID_LIMIT) or (DTW.ID_LIMIT = L.ID_LIMIT)
      where A.ID_ORGANIZATION_INSURANCE is not null
      group by A.ID_APPLICATION, OI.ID_SCOPE_WORK
    )

  select A.ID_APPLICATION,
    (case
      when A.TW_COUNT >= 10 then
        case SW.INDEX_
          when 1 then 2000000
          when 2 then 3500000
          when 3 then 6000000
          when 4 then 8000000
          when 5 then 12000000
          when 6 then 18000000
          when 7 then 25000000
          else 0
        end
      when A.TW_COUNT >= 5 then
        case SW.INDEX_
          when 1 then 1000000
          when 2 then 1500000
          when 3 then 2500000
          when 4 then 4000000
          when 5 then 6000000
          when 6 then 9000000
          when 7 then 15000000
          else 0
        end
      when A.TW_COUNT >= 2 then
        case SW.INDEX_
          when 1 then 800000
          when 2 then 900000
          when 3 then 1000000
          when 4 then 2000000
          when 5 then 3000000
          when 6 then 4500000
          when 7 then 7000000
          else 0
        end
      when A.TW_COUNT = 1 then
        case SW.INDEX_
          when 1 then 700000
          when 2 then 800000
          when 3 then 900000
          when 4 then 1000000
          when 5 then 1500000
          when 6 then 2000000
          when 7 then 3000000
          else 0
        end
      else
        0
     end) * A.TW_COUNT_MULTI
    + A.TW_32 * A.TW_32_MULTI
    + A.TW_33 * A.TW_33_MULTI
    + cast(0 as TQUANTITY)
  from APPLICATION_ A
  left join SCOPE_WORK SW on SW.ID_SCOPE_WORK = A.ID_SCOPE_WORK
;



/* View: FIRST_PROTOCOL */
CREATE VIEW FIRST_PROTOCOL(
    ID_REGISTER,
    ID_PROTOCOL,
    DECISION_DATE,
    NUMBER)
AS
with
  BASE as (
    select R.ID_REGISTER, min(P.ID_PROTOCOL) as ID_PROTOCOL
    from REGISTER R
    left join APPLICATION A on A.ID_REGISTER = R.ID_REGISTER
    left join RIGHT_ RT on RT.ID_REGISTER = R.ID_REGISTER
    left join PROTOCOL P on P.ID_PROTOCOL = coalesce(A.ID_PROTOCOL, RT.ID_PROTOCOL)
    group by R.ID_REGISTER)

select B.ID_REGISTER, B.ID_PROTOCOL, P.DECISION_DATE, P.NUMBER
from BASE B
left join PROTOCOL P on P.ID_PROTOCOL = B.ID_PROTOCOL
;



/* View: FIRST_RIGHT */
CREATE VIEW FIRST_RIGHT(
    ID_REGISTER,
    ID_PROTOCOL,
    DECISION_DATE,
    NUMBER)
AS
with
  BASE as (
    select R.ID_REGISTER, min(P.ID_PROTOCOL) as ID_PROTOCOL
    from REGISTER R
    left join RIGHT_ RT on RT.ID_REGISTER = R.ID_REGISTER
    left join PROTOCOL P on P.ID_PROTOCOL = RT.ID_PROTOCOL
    group by R.ID_REGISTER)

select B.ID_REGISTER, B.ID_PROTOCOL, P.DECISION_DATE, P.NUMBER
from BASE B
left join PROTOCOL P on P.ID_PROTOCOL = B.ID_PROTOCOL
;




/******************************************************************************/
/***                           Unique constraints                           ***/
/******************************************************************************/

ALTER TABLE APP$REPORTS ADD CONSTRAINT UNQ1_APP$REPORTS UNIQUE (REPORT_NAME);
ALTER TABLE APP$UPDATE ADD CONSTRAINT UNQ1_APP$UPDATE UNIQUE (FILE_NAME);
ALTER TABLE REGION ADD CONSTRAINT UNQ1_REGION UNIQUE (CODE);
ALTER TABLE REGISTER ADD CONSTRAINT UNQ1_REGISTER UNIQUE (ID_ORGANIZATION_);
ALTER TABLE RIGHT_ ADD CONSTRAINT UNQ1_RIGHT_ UNIQUE (ID_REGISTER, ID_PROTOCOL);
ALTER TABLE SCOPE_WORK ADD CONSTRAINT UNQ1_SCOPE_WORK UNIQUE (INDEX_);


/******************************************************************************/
/***                              Primary keys                              ***/
/******************************************************************************/

ALTER TABLE APP$BANS ADD CONSTRAINT PK_APP$BANS PRIMARY KEY (ID_BANS);
ALTER TABLE APP$EXCEPTION ADD CONSTRAINT PK_APP$EXCEPTION PRIMARY KEY (ID_EXCEPTION);
ALTER TABLE APP$KEY ADD CONSTRAINT PK_APP$KEY PRIMARY KEY (ID_KEY);
ALTER TABLE APP$NEW_UPDATE ADD CONSTRAINT PK_APP$NEW_UPDATE PRIMARY KEY (ID_NEW_UPDATE);
ALTER TABLE APP$PARAMETER ADD CONSTRAINT PK_APP$PARAMETER PRIMARY KEY (ID_PARAMETER);
ALTER TABLE APP$REPORTS ADD CONSTRAINT PK_APP$REPORTS PRIMARY KEY (ID_REPORTS);
ALTER TABLE APP$REPORTS_HTML ADD CONSTRAINT PK_APP$REPORTS_HTML PRIMARY KEY (ID_REPORTS_HTML);
ALTER TABLE APP$REPORTS_PARAMETER ADD CONSTRAINT PK_APP$REPORTS_PARAMETER PRIMARY KEY (ID_REPORTS_PARAMETER);
ALTER TABLE APP$ROLES ADD CONSTRAINT PK_APP$ROLES PRIMARY KEY (ID_ROLES);
ALTER TABLE APP$UPDATE ADD CONSTRAINT PK_APP$UPDATE PRIMARY KEY (ID_UPDATE);
ALTER TABLE APP$UPDATE_NEW ADD CONSTRAINT PK_APP$UPDATE_NEW PRIMARY KEY (ID_NEW_UPDATE, ID_UPDATE);
ALTER TABLE APP$USERS ADD CONSTRAINT PK_APP$USERS PRIMARY KEY (ID_USERS);
ALTER TABLE APPLICATION ADD CONSTRAINT PK_APPLICATION PRIMARY KEY (ID_APPLICATION);
ALTER TABLE APPLICATION_STATUS ADD CONSTRAINT PK_APPLICATION_STATUS PRIMARY KEY (ID_APPLICATION_STATUS);
ALTER TABLE APPLICATION_TYPE_WORK ADD CONSTRAINT PK_APPLICATION_TYPE_WORK PRIMARY KEY (ID_APPLICATION, ID_TYPE_WORK);
ALTER TABLE CHECK_RESULT ADD CONSTRAINT PK_CHECK_RESULT PRIMARY KEY (ID_CHECK_RESULT);
ALTER TABLE CONFIG_ ADD CONSTRAINT PK_CONFIG_ PRIMARY KEY (ID_CONFIG);
ALTER TABLE CUSTOMER_DEBT ADD CONSTRAINT PK_CUSTOMER_DEBT PRIMARY KEY (ID_CUSTOMER_DEBT);
ALTER TABLE DEPARTMENT ADD CONSTRAINT PK_DEPARTMENT PRIMARY KEY (ID_DEPARTMENT);
ALTER TABLE DESCRIPTION_TYPE_WORK ADD CONSTRAINT PK_DESCRIPTION_TYPE_WORK PRIMARY KEY (ID_DESCRIPTION_TYPE_WORK);
ALTER TABLE EMPLOYEES ADD CONSTRAINT PK_EMPLOYEES PRIMARY KEY (ID_EMPLOYEES);
ALTER TABLE EXPELLED ADD CONSTRAINT PK_EXPELLED PRIMARY KEY (ID_EXPELLED);
ALTER TABLE FOUNDERS ADD CONSTRAINT PK_FOUNDERS PRIMARY KEY (ID_FOUNDERS);
ALTER TABLE FUND_SUM_CONTRACT ADD CONSTRAINT PK_FUND_SUM_CONTRACT PRIMARY KEY (ID_FUND_SUM_CONTRACT);
ALTER TABLE FUND_SUM_HARM ADD CONSTRAINT PK_FUND_SUM_HARM PRIMARY KEY (ID_FUND_SUM_HARM);
ALTER TABLE GROUP_TYPE_WORK ADD CONSTRAINT PK_GROUP_TYPE_WORK PRIMARY KEY (ID_GROUP_TYPE_WORK);
ALTER TABLE INFRINGEMENTS ADD CONSTRAINT PK_INFRINGEMENTS PRIMARY KEY (ID_INFRINGEMENTS);
ALTER TABLE INSURANCE ADD CONSTRAINT PK_INSURANCE PRIMARY KEY (ID_INSURANCE);
ALTER TABLE INSURANCE_SUBJECT ADD CONSTRAINT PK_INSURANCE_SUBJECT PRIMARY KEY (ID_INSURANCE_SUBJECT);
ALTER TABLE INSURANCE_TYPE_WORK ADD CONSTRAINT PK_INSURANCE_TYPE_WORK PRIMARY KEY (ID_ORGANIZATION_INSURANCE, ID_TYPE_WORK);
ALTER TABLE INTERVENTION ADD CONSTRAINT PK_INTERVENTION PRIMARY KEY (ID_INTERVENTION);
ALTER TABLE LEGAL_FORM ADD CONSTRAINT PK_LEGAL_FORM PRIMARY KEY (ID_LEGAL_FORM);
ALTER TABLE LEVEL_CONTRACTOR ADD CONSTRAINT PK_LEVEL_CONTRACTOR PRIMARY KEY (ID_LEVEL_CONTRACTOR);
ALTER TABLE LEVEL_HARM ADD CONSTRAINT PK_LEVEL_HARM PRIMARY KEY (ID_LEVEL_HARM);
ALTER TABLE LIMIT ADD CONSTRAINT PK_LIMIT PRIMARY KEY (ID_LIMIT);
ALTER TABLE MEASURE ADD CONSTRAINT PK_MEASURE PRIMARY KEY (ID_MEASURE);
ALTER TABLE ORGANIZATION_ ADD CONSTRAINT PK_ORGANIZATION_ PRIMARY KEY (ID_ORGANIZATION_);
ALTER TABLE ORGANIZATION_HISTORY ADD CONSTRAINT PK_ORGANIZATION_HISTORY PRIMARY KEY (ID_ORGANIZATION_HISTORY);
ALTER TABLE ORGANIZATION_INSURANCE ADD CONSTRAINT PK_ORGANIZATION_INSURANCE PRIMARY KEY (ID_ORGANIZATION_INSURANCE);
ALTER TABLE ORGANIZATION_ISSUE ADD CONSTRAINT PK_ORGANIZATION_ISSUE PRIMARY KEY (ID_ORGANIZATION_ISSUE);
ALTER TABLE PERILOUS ADD CONSTRAINT PK_PERILOUS PRIMARY KEY (ID_PERILOUS);
ALTER TABLE PERSON ADD CONSTRAINT PK_PERSON PRIMARY KEY (ID_PERSON);
ALTER TABLE PROTOCOL ADD CONSTRAINT PK_PROTOCOL PRIMARY KEY (ID_PROTOCOL);
ALTER TABLE REGION ADD CONSTRAINT PK_REGION PRIMARY KEY (ID_REGION);
ALTER TABLE REGISTER ADD CONSTRAINT PK_REGISTER PRIMARY KEY (ID_REGISTER);
ALTER TABLE REGISTER_CHECK ADD CONSTRAINT PK_REGISTER_CHECK PRIMARY KEY (ID_REGISTER_CHECK);
ALTER TABLE RIGHT_ ADD CONSTRAINT PK_RIGHT_ PRIMARY KEY (ID_RIGHT);
ALTER TABLE SCOPE_WORK ADD CONSTRAINT PK_SCOPE_WORK PRIMARY KEY (ID_SCOPE_WORK);
ALTER TABLE TYPE_CHECK ADD CONSTRAINT PK_TYPE_CHECK PRIMARY KEY (ID_TYPE_CHECK);
ALTER TABLE TYPE_WORK ADD CONSTRAINT PK_TYPE_WORK PRIMARY KEY (ID_TYPE_WORK);
ALTER TABLE VERIFICATION ADD CONSTRAINT PK_VERIFICATION PRIMARY KEY (ID_VERIFICATION);
ALTER TABLE VERIFICATION_INFRINGEMENTS ADD CONSTRAINT PK_VERIFICATION_INFRINGEMENTS PRIMARY KEY (ID_VERIFICATION, ID_INFRINGEMENTS);


/******************************************************************************/
/***                              Foreign keys                              ***/
/******************************************************************************/

ALTER TABLE APP$BANS ADD CONSTRAINT FK_APP$BANS_1 FOREIGN KEY (ID_ROLES) REFERENCES APP$ROLES (ID_ROLES) ON DELETE CASCADE;
ALTER TABLE APP$PARAMETER ADD CONSTRAINT FK_APP$PARAMETER_1 FOREIGN KEY (REPORTS_ID) REFERENCES APP$REPORTS (ID_REPORTS) ON DELETE CASCADE;
ALTER TABLE APP$REPORTS ADD CONSTRAINT FK_APP$REPORTS_1 FOREIGN KEY (PARENT_REPORT) REFERENCES APP$REPORTS (ID_REPORTS) ON DELETE CASCADE;
ALTER TABLE APP$REPORTS_HTML ADD CONSTRAINT FK_APP$REPORTS_HTML_1 FOREIGN KEY (PARENT_ID) REFERENCES APP$REPORTS_HTML (ID_REPORTS_HTML) ON DELETE CASCADE;
ALTER TABLE APP$REPORTS_HTML ADD CONSTRAINT FK_APP$REPORTS_HTML_2 FOREIGN KEY (REPORTS_ID) REFERENCES APP$REPORTS (ID_REPORTS) ON DELETE CASCADE;
ALTER TABLE APP$REPORTS_PARAMETER ADD CONSTRAINT FK_APP$REPORTS_PARAMETER_1 FOREIGN KEY (REPORTS_ID) REFERENCES APP$REPORTS (ID_REPORTS) ON DELETE CASCADE;
ALTER TABLE APP$UPDATE_NEW ADD CONSTRAINT FK_APP$UPDATE_NEW_1 FOREIGN KEY (ID_UPDATE) REFERENCES APP$UPDATE (ID_UPDATE);
ALTER TABLE APP$UPDATE_NEW ADD CONSTRAINT FK_APP$UPDATE_NEW_2 FOREIGN KEY (ID_NEW_UPDATE) REFERENCES APP$NEW_UPDATE (ID_NEW_UPDATE) ON DELETE CASCADE;
ALTER TABLE APP$USERS ADD CONSTRAINT FK_APP$USERS_1 FOREIGN KEY (ID_ROLES) REFERENCES APP$ROLES (ID_ROLES);
ALTER TABLE APPLICATION ADD CONSTRAINT FK_APPLICATION_1 FOREIGN KEY (ID_REGISTER) REFERENCES REGISTER (ID_REGISTER) ON DELETE CASCADE;
ALTER TABLE APPLICATION ADD CONSTRAINT FK_APPLICATION_2 FOREIGN KEY (ID_PROTOCOL) REFERENCES PROTOCOL (ID_PROTOCOL);
ALTER TABLE APPLICATION ADD CONSTRAINT FK_APPLICATION_3 FOREIGN KEY (ID_APPLICATION_STATUS) REFERENCES APPLICATION_STATUS (ID_APPLICATION_STATUS);
ALTER TABLE APPLICATION ADD CONSTRAINT FK_APPLICATION_4 FOREIGN KEY (ID_LIMIT) REFERENCES LIMIT (ID_LIMIT);
ALTER TABLE APPLICATION ADD CONSTRAINT FK_APPLICATION_5 FOREIGN KEY (ID_ORGANIZATION_INSURANCE) REFERENCES ORGANIZATION_INSURANCE (ID_ORGANIZATION_INSURANCE);
ALTER TABLE APPLICATION_TYPE_WORK ADD CONSTRAINT FK_APPLICATION_TYPE_WORK_1 FOREIGN KEY (ID_APPLICATION) REFERENCES APPLICATION (ID_APPLICATION) ON DELETE CASCADE;
ALTER TABLE APPLICATION_TYPE_WORK ADD CONSTRAINT FK_APPLICATION_TYPE_WORK_2 FOREIGN KEY (ID_TYPE_WORK) REFERENCES TYPE_WORK (ID_TYPE_WORK);
ALTER TABLE APPLICATION_TYPE_WORK ADD CONSTRAINT FK_APPLICATION_TYPE_WORK_3 FOREIGN KEY (ID_PERILOUS) REFERENCES PERILOUS (ID_PERILOUS);
ALTER TABLE APPLICATION_TYPE_WORK ADD CONSTRAINT FK_APPLICATION_TYPE_WORK_4 FOREIGN KEY (ID_DESCRIPTION) REFERENCES DESCRIPTION_TYPE_WORK (ID_DESCRIPTION_TYPE_WORK);
ALTER TABLE APPLICATION_TYPE_WORK ADD CONSTRAINT FK_APPLICATION_TYPE_WORK_5 FOREIGN KEY (ID_LIMIT) REFERENCES LIMIT (ID_LIMIT);
ALTER TABLE CONFIG_ ADD CONSTRAINT FK_CONFIG__1 FOREIGN KEY (ID_APPLICATION_STATUS_RESET) REFERENCES APPLICATION_STATUS (ID_APPLICATION_STATUS);
ALTER TABLE CONFIG_ ADD CONSTRAINT FK_CONFIG__2 FOREIGN KEY (ID_APPLICATION_STATUS_END) REFERENCES APPLICATION_STATUS (ID_APPLICATION_STATUS);
ALTER TABLE CONFIG_ ADD CONSTRAINT FK_CONFIG__3 FOREIGN KEY (ID_APPLICATION_STATUS_ACTIVE) REFERENCES APPLICATION_STATUS (ID_APPLICATION_STATUS);
ALTER TABLE CONFIG_ ADD CONSTRAINT FK_CONFIG__4 FOREIGN KEY (ID_APPLICATION_STATUS_SUSPENDED) REFERENCES APPLICATION_STATUS (ID_APPLICATION_STATUS);
ALTER TABLE CONFIG_ ADD CONSTRAINT FK_CONFIG__5 FOREIGN KEY (ID_PERILOUS) REFERENCES PERILOUS (ID_PERILOUS);
ALTER TABLE CONFIG_ ADD CONSTRAINT FK_CONFIG__6 FOREIGN KEY (ID_REGION) REFERENCES REGION (ID_REGION);
ALTER TABLE CUSTOMER_DEBT ADD CONSTRAINT FK_CUSTOMER_DEBT_1 FOREIGN KEY (ID_REGISTER) REFERENCES REGISTER (ID_REGISTER) ON DELETE CASCADE;
ALTER TABLE DESCRIPTION_TYPE_WORK ADD CONSTRAINT FK_DESCRIPTION_TYPE_WORK_1 FOREIGN KEY (ID_LIMIT) REFERENCES LIMIT (ID_LIMIT);
ALTER TABLE EMPLOYEES ADD CONSTRAINT FK_EMPLOYEES_1 FOREIGN KEY (ID_ORGANIZATION_) REFERENCES ORGANIZATION_ (ID_ORGANIZATION_);
ALTER TABLE FOUNDERS ADD CONSTRAINT FK_FOUNDERS_1 FOREIGN KEY (ID_ORGANIZATION_) REFERENCES ORGANIZATION_ (ID_ORGANIZATION_) ON DELETE CASCADE;
ALTER TABLE FOUNDERS ADD CONSTRAINT FK_FOUNDERS_2 FOREIGN KEY (ID_PERSON) REFERENCES PERSON (ID_PERSON);
ALTER TABLE FOUNDERS ADD CONSTRAINT FK_FOUNDERS_3 FOREIGN KEY (ID_ORGANIZATION__) REFERENCES ORGANIZATION_ (ID_ORGANIZATION_);
ALTER TABLE INSURANCE_TYPE_WORK ADD CONSTRAINT FK_INSURANCE_TYPE_WORK_1 FOREIGN KEY (ID_ORGANIZATION_INSURANCE) REFERENCES ORGANIZATION_INSURANCE (ID_ORGANIZATION_INSURANCE) ON DELETE CASCADE;
ALTER TABLE INSURANCE_TYPE_WORK ADD CONSTRAINT FK_INSURANCE_TYPE_WORK_2 FOREIGN KEY (ID_TYPE_WORK) REFERENCES TYPE_WORK (ID_TYPE_WORK);
ALTER TABLE INTERVENTION ADD CONSTRAINT FK_INTERVENTION_1 FOREIGN KEY (ID_DEPARTMENT) REFERENCES DEPARTMENT (ID_DEPARTMENT);
ALTER TABLE INTERVENTION ADD CONSTRAINT FK_INTERVENTION_2 FOREIGN KEY (ID_MEASURE) REFERENCES MEASURE (ID_MEASURE);
ALTER TABLE ORGANIZATION_ ADD CONSTRAINT FK_ORGANIZATION__1 FOREIGN KEY (ID_LEGAL_FORM) REFERENCES LEGAL_FORM (ID_LEGAL_FORM);
ALTER TABLE ORGANIZATION_ ADD CONSTRAINT FK_ORGANIZATION__2 FOREIGN KEY (ID_ORGANIZATION_ISSUE) REFERENCES ORGANIZATION_ISSUE (ID_ORGANIZATION_ISSUE);
ALTER TABLE ORGANIZATION_ ADD CONSTRAINT FK_ORGANIZATION__3 FOREIGN KEY (ID_PERSON) REFERENCES PERSON (ID_PERSON);
ALTER TABLE ORGANIZATION_ ADD CONSTRAINT FK_ORGANIZATION__4 FOREIGN KEY (ID_REGION) REFERENCES REGION (ID_REGION);
ALTER TABLE ORGANIZATION_HISTORY ADD CONSTRAINT FK_ORGANIZATION_HISTORY_1 FOREIGN KEY (ID_LEGAL_FORM) REFERENCES LEGAL_FORM (ID_LEGAL_FORM);
ALTER TABLE ORGANIZATION_HISTORY ADD CONSTRAINT FK_ORGANIZATION_HISTORY_2 FOREIGN KEY (ID_ORGANIZATION_ISSUE) REFERENCES ORGANIZATION_ISSUE (ID_ORGANIZATION_ISSUE);
ALTER TABLE ORGANIZATION_HISTORY ADD CONSTRAINT FK_ORGANIZATION_HISTORY_3 FOREIGN KEY (ID_PERSON) REFERENCES PERSON (ID_PERSON);
ALTER TABLE ORGANIZATION_HISTORY ADD CONSTRAINT FK_ORGANIZATION_HISTORY_4 FOREIGN KEY (ID_ORGANIZATION_) REFERENCES ORGANIZATION_ (ID_ORGANIZATION_) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORGANIZATION_INSURANCE ADD CONSTRAINT FK_ORGANIZATION_INSURANCE_1 FOREIGN KEY (ID_ORGANIZATION_) REFERENCES ORGANIZATION_ (ID_ORGANIZATION_) ON DELETE CASCADE;
ALTER TABLE ORGANIZATION_INSURANCE ADD CONSTRAINT FK_ORGANIZATION_INSURANCE_2 FOREIGN KEY (ID_INSURANCE) REFERENCES INSURANCE (ID_INSURANCE);
ALTER TABLE ORGANIZATION_INSURANCE ADD CONSTRAINT FK_ORGANIZATION_INSURANCE_3 FOREIGN KEY (ID_SCOPE_WORK) REFERENCES SCOPE_WORK (ID_SCOPE_WORK);
ALTER TABLE ORGANIZATION_INSURANCE ADD CONSTRAINT FK_ORGANIZATION_INSURANCE_4 FOREIGN KEY (ID_INSURANCE_SUBJECT) REFERENCES INSURANCE_SUBJECT (ID_INSURANCE_SUBJECT);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_1 FOREIGN KEY (ID_ORGANIZATION_) REFERENCES ORGANIZATION_ (ID_ORGANIZATION_);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_2 FOREIGN KEY (ID_APPLICATION) REFERENCES APPLICATION (ID_APPLICATION) ON DELETE SET NULL;
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_3 FOREIGN KEY (ID_EXPELLED) REFERENCES EXPELLED (ID_EXPELLED);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_4 FOREIGN KEY (ID_FUND_SUM_HARM) REFERENCES FUND_SUM_HARM (ID_FUND_SUM_HARM);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_5 FOREIGN KEY (ID_FUND_SUM_CONTRACT) REFERENCES FUND_SUM_CONTRACT (ID_FUND_SUM_CONTRACT);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_6 FOREIGN KEY (ID_RIGHT) REFERENCES RIGHT_ (ID_RIGHT);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_7 FOREIGN KEY (ID_FUND_LEVEL_HARM) REFERENCES LEVEL_HARM (ID_LEVEL_HARM);
ALTER TABLE REGISTER ADD CONSTRAINT FK_REGISTER_8 FOREIGN KEY (ID_FUND_LEVEL_CONTRACT) REFERENCES LEVEL_CONTRACTOR (ID_LEVEL_CONTRACTOR);
ALTER TABLE REGISTER_CHECK ADD CONSTRAINT FK_REGISTER_CHECK_1 FOREIGN KEY (ID_REGISTER) REFERENCES REGISTER (ID_REGISTER) ON DELETE CASCADE;
ALTER TABLE REGISTER_CHECK ADD CONSTRAINT FK_REGISTER_CHECK_2 FOREIGN KEY (ID_TYPE_CHECK) REFERENCES TYPE_CHECK (ID_TYPE_CHECK);
ALTER TABLE REGISTER_CHECK ADD CONSTRAINT FK_REGISTER_CHECK_3 FOREIGN KEY (ID_CHECK_RESULT) REFERENCES CHECK_RESULT (ID_CHECK_RESULT);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__1 FOREIGN KEY (ID_REGISTER) REFERENCES REGISTER (ID_REGISTER);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__2 FOREIGN KEY (ID_PROTOCOL) REFERENCES PROTOCOL (ID_PROTOCOL);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__3 FOREIGN KEY (ID_APPLICATION_STATUS) REFERENCES APPLICATION_STATUS (ID_APPLICATION_STATUS);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__4 FOREIGN KEY (ID_PERILOUS) REFERENCES PERILOUS (ID_PERILOUS);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__5 FOREIGN KEY (ID_PROTOCOL_CONTRACT) REFERENCES PROTOCOL (ID_PROTOCOL);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__6 FOREIGN KEY (ID_FUND_LEVEL_HARM) REFERENCES LEVEL_HARM (ID_LEVEL_HARM);
ALTER TABLE RIGHT_ ADD CONSTRAINT FK_RIGHT__7 FOREIGN KEY (ID_FUND_LEVEL_CONTRACT) REFERENCES LEVEL_CONTRACTOR (ID_LEVEL_CONTRACTOR);
ALTER TABLE TYPE_WORK ADD CONSTRAINT FK_TYPE_WORK_1 FOREIGN KEY (ID_GROUP_TYPE_WORK) REFERENCES GROUP_TYPE_WORK (ID_GROUP_TYPE_WORK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TYPE_WORK ADD CONSTRAINT FK_TYPE_WORK_2 FOREIGN KEY (ID_PERILOUS) REFERENCES PERILOUS (ID_PERILOUS);
ALTER TABLE VERIFICATION ADD CONSTRAINT FK_VERIFICATION_1 FOREIGN KEY (ID_REGISTER) REFERENCES REGISTER (ID_REGISTER) ON DELETE CASCADE;
ALTER TABLE VERIFICATION ADD CONSTRAINT FK_VERIFICATION_2 FOREIGN KEY (ID_MEASURE) REFERENCES MEASURE (ID_MEASURE);
ALTER TABLE VERIFICATION_INFRINGEMENTS ADD CONSTRAINT FK_VERIFICATION_INFRINGEMENTS_1 FOREIGN KEY (ID_VERIFICATION) REFERENCES VERIFICATION (ID_VERIFICATION) ON DELETE CASCADE;
ALTER TABLE VERIFICATION_INFRINGEMENTS ADD CONSTRAINT FK_VERIFICATION_INFRINGEMENTS_2 FOREIGN KEY (ID_INFRINGEMENTS) REFERENCES INFRINGEMENTS (ID_INFRINGEMENTS);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE UNIQUE INDEX REGISTER_IDX1 ON REGISTER (CODE);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/



SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: APP$BANS_BI */
CREATE TRIGGER APP$BANS_BI FOR APP$BANS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_BANS IS NULL) THEN
    NEW.ID_BANS = GEN_ID(GEN_APP$BANS_ID, 1);
END
^

/* Trigger: APP$EXCEPTION_BI */
CREATE TRIGGER APP$EXCEPTION_BI FOR APP$EXCEPTION
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_EXCEPTION IS NULL) THEN
    NEW.ID_EXCEPTION = GEN_ID(GEN_APP$EXCEPTION_ID, 1);
END
^

/* Trigger: APP$KEY_BI */
CREATE TRIGGER APP$KEY_BI FOR APP$KEY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_KEY IS NULL) THEN
    NEW.ID_KEY = GEN_ID(GEN_APP$KEY_ID,1);

  IF (NEW.USER_ IS NULL) THEN
    NEW.USER_ = user;
END
^

/* Trigger: APP$NEW_UPDATE_BI */
CREATE TRIGGER APP$NEW_UPDATE_BI FOR APP$NEW_UPDATE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_NEW_UPDATE IS NULL) THEN
    NEW.ID_NEW_UPDATE = GEN_ID(GEN_APP$NEW_UPDATE_ID,1);

  NEW.DATE_TIME = 'now';
END
^

/* Trigger: APP$PARAMETER_BI */
CREATE TRIGGER APP$PARAMETER_BI FOR APP$PARAMETER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_PARAMETER IS NULL) THEN
    NEW.ID_PARAMETER = GEN_ID(GEN_APP$PARAMETER_ID, 1);

  if (new.INDEX_ is null) then
    select coalesce(max(P.INDEX_) + 1, 0)
    from APP$PARAMETER P
    where P.REPORTS_ID = new.REPORTS_ID
    into new.INDEX_;
END
^

/* Trigger: APP$PARAMETER_BU0 */
CREATE TRIGGER APP$PARAMETER_BU0 FOR APP$PARAMETER
ACTIVE BEFORE UPDATE POSITION 0
AS
  declare variable INDEX_ int;
begin
  if (RDB$GET_CONTEXT('USER_SESSION', 'INDEX') is null) then
  begin
    select
      case
        when new.INDEX_ > old.INDEX_ then min(P.INDEX_)
        when new.INDEX_ < old.INDEX_ then max(P.INDEX_)
      end
    from APP$PARAMETER P
    where coalesce(P.REPORTS_ID, 0) = coalesce(old.REPORTS_ID, 0)
      and ((new.INDEX_ > old.INDEX_ and P.INDEX_ > old.INDEX_)
            or (new.INDEX_ < old.INDEX_ and P.INDEX_ < old.INDEX_))
    into :INDEX_;
    
    if (:INDEX_ is null) then
      new.INDEX_ = old.INDEX_;
    else
    begin
      RDB$SET_CONTEXT('USER_SESSION', 'INDEX', '1');
      update APP$PARAMETER P set
        P.INDEX_ = old.INDEX_
      where coalesce(P.REPORTS_ID, 0) = coalesce(old.REPORTS_ID, 0) and P.INDEX_ = :INDEX_;
      RDB$SET_CONTEXT('USER_SESSION', 'INDEX', null);
    end
  end
end
^

/* Trigger: APP$REPORTS_BI */
CREATE TRIGGER APP$REPORTS_BI FOR APP$REPORTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_REPORTS IS NULL) THEN
    NEW.ID_REPORTS = GEN_ID(GEN_APP$REPORTS_ID, 1);

  if (new.INDEX_ is null) then
    select coalesce(max(R.INDEX_) + 1, 0)
    from APP$REPORTS R
    where coalesce(R.PARENT_REPORT, 0) = coalesce(new.PARENT_REPORT, 0)
    into new.INDEX_;
END
^

/* Trigger: APP$REPORTS_BU0 */
CREATE TRIGGER APP$REPORTS_BU0 FOR APP$REPORTS
ACTIVE BEFORE UPDATE POSITION 0
AS
  declare variable INDEX_ int;
begin
  if (RDB$GET_CONTEXT('USER_SESSION', 'INDEX') is null) then
  begin
    select
      case
        when new.INDEX_ > old.INDEX_ then min(R.INDEX_)
        when new.INDEX_ < old.INDEX_ then max(R.INDEX_)
      end
    from APP$REPORTS R
    where coalesce(R.PARENT_REPORT, 0) = coalesce(old.PARENT_REPORT, 0)
      and ((new.INDEX_ > old.INDEX_ and R.INDEX_ > old.INDEX_)
            or (new.INDEX_ < old.INDEX_ and R.INDEX_ < old.INDEX_))
    into :INDEX_;
    
    if (:INDEX_ is null) then
      new.INDEX_ = old.INDEX_;
    else
    begin
      RDB$SET_CONTEXT('USER_SESSION', 'INDEX', '1');
      update APP$REPORTS R set
        R.INDEX_ = old.INDEX_
      where coalesce(R.PARENT_REPORT, 0) = coalesce(old.PARENT_REPORT, 0) and R.INDEX_ = :INDEX_;
      RDB$SET_CONTEXT('USER_SESSION', 'INDEX', null);
    end
  end
end
^

/* Trigger: APP$REPORTS_HTML_BI */
CREATE TRIGGER APP$REPORTS_HTML_BI FOR APP$REPORTS_HTML
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_REPORTS_HTML IS NULL) THEN
    NEW.ID_REPORTS_HTML = GEN_ID(GEN_APP$REPORTS_HTML_ID, 1);

  select coalesce(max(R.INDEX_) + 1, 0)
  from APP$REPORTS_HTML R
  where coalesce(R.PARENT_ID, 0) = coalesce(new.PARENT_ID, 0) and (R.REPORTS_ID = new.REPORTS_ID)
  into new.INDEX_;
END
^

/* Trigger: APP$REPORTS_HTML_BU0 */
CREATE TRIGGER APP$REPORTS_HTML_BU0 FOR APP$REPORTS_HTML
ACTIVE BEFORE UPDATE POSITION 0
AS
  declare variable INDEX_ int;
begin
  if ((old.INDEX_ <> new.INDEX_) and (RDB$GET_CONTEXT('USER_SESSION', 'INDEX') is null)) then
  begin
    select
      case
        when new.INDEX_ > old.INDEX_ then min(R.INDEX_)
        when new.INDEX_ <= old.INDEX_ then max(R.INDEX_)
      end
    from APP$REPORTS_HTML R
    where coalesce(R.PARENT_ID, 0) = coalesce(old.PARENT_ID, 0) and R.REPORTS_ID = old.REPORTS_ID
      and ((new.INDEX_ > old.INDEX_ and R.INDEX_ > old.INDEX_)
            or (new.INDEX_ < old.INDEX_ and R.INDEX_ < old.INDEX_))
    into :INDEX_;
    
    if (:INDEX_ is null) then
      new.INDEX_ = old.INDEX_;
    else
    begin
      RDB$SET_CONTEXT('USER_SESSION', 'INDEX', '1');
      update APP$REPORTS_HTML R set
        R.INDEX_ = old.INDEX_
      where coalesce(R.PARENT_ID, 0) = coalesce(old.PARENT_ID, 0)
        and R.REPORTS_ID = old.REPORTS_ID and R.INDEX_ = :INDEX_;
      RDB$SET_CONTEXT('USER_SESSION', 'INDEX', null);
    end
  end
end
^

/* Trigger: APP$REPORTS_PARAMETER_BI */
CREATE TRIGGER APP$REPORTS_PARAMETER_BI FOR APP$REPORTS_PARAMETER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_REPORTS_PARAMETER IS NULL) THEN
    NEW.ID_REPORTS_PARAMETER = GEN_ID(GEN_APP$REPORTS_PARAMETER_ID, 1);
END
^

/* Trigger: APP$ROLES_BI */
CREATE TRIGGER APP$ROLES_BI FOR APP$ROLES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_ROLES IS NULL) THEN
    NEW.ID_ROLES = GEN_ID(GEN_APP$ROLES_ID, 1);
END
^

/* Trigger: APP$UPDATE_BI */
CREATE TRIGGER APP$UPDATE_BI FOR APP$UPDATE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_UPDATE IS NULL) THEN
    NEW.ID_UPDATE = GEN_ID(GEN_APP$UPDATE_ID,1);
END
^

/* Trigger: APP$UPDATE_BU0 */
CREATE TRIGGER APP$UPDATE_BU0 FOR APP$UPDATE
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
begin
  new.DATE_TIME = cast('now' as timestamp);
end
^

/* Trigger: APP$USERS_BI */
CREATE TRIGGER APP$USERS_BI FOR APP$USERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_USERS IS NULL) THEN
    NEW.ID_USERS = GEN_ID(GEN_APP$USERS_ID, 1);
END
^

/* Trigger: APPLICATION_AIUD0 */
CREATE TRIGGER APPLICATION_AIUD0 FOR APPLICATION
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
  declare variable ID_REGISTER int;
begin
  if (deleting) then
    ID_REGISTER = old.ID_REGISTER;
  else
    ID_REGISTER = new.ID_REGISTER;

  update REGISTER R set
    R.ID_APPLICATION = (select LA.ID_APPLICATION from LAST_APPLICATION(R.CODE) LA)
  where R.ID_REGISTER = :ID_REGISTER;
end
^

/* Trigger: APPLICATION_BI */
CREATE TRIGGER APPLICATION_BI FOR APPLICATION
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_APPLICATION IS NULL) THEN
    NEW.ID_APPLICATION = GEN_ID(GEN_APPLICATION_ID,1);
END
^

/* Trigger: APPLICATION_BIU0 */
CREATE TRIGGER APPLICATION_BIU0 FOR APPLICATION
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
  declare variable REG_CODE int;
  declare variable ID_APPLICATION_STATUS_RESET int;
  declare variable ID_APPLICATION int;
begin
  if (coalesce(old.ID_APPLICATION_STATUS, 0) <> new.ID_APPLICATION_STATUS) then
    new.STATUS_DATE = 'TODAY';

  if ((old.ID_PROTOCOL is null) and (new.ID_PROTOCOL is not null)) then
  begin
    REG_CODE = null;
    select R.CODE
    from REGISTER R
    where R.ID_REGISTER = new.ID_REGISTER
    into :REG_CODE;

    if (REG_CODE is null) then
    begin
      REG_CODE = GEN_ID(GEN_REGISTER_CODE,1);

      update REGISTER R set
        R.CODE = :REG_CODE
      where (R.ID_REGISTER = new.ID_REGISTER) and (R.CODE is null);
    end

    select D.NUMBER
    from PROTOCOL P
    left join DATA_GET_NUMBER(:REG_CODE, P.DECISION_DATE) D on 0=0
    where P.ID_PROTOCOL = new.ID_PROTOCOL and old.CERTIFICATE is null
    into new.CERTIFICATE;

    ID_APPLICATION_STATUS_RESET = null;
    select C.ID_APPLICATION_STATUS_RESET
    from CONFIG C
    into :ID_APPLICATION_STATUS_RESET;

    ID_APPLICATION = null;
    select A.ID_APPLICATION
    from APPLICATION A
    where A.ID_REGISTER = new.ID_REGISTER
      and A.ID_APPLICATION_STATUS <> :ID_APPLICATION_STATUS_RESET
      and A.ID_APPLICATION < new.ID_APPLICATION
    order by A.ID_APPLICATION desc
    rows 1
    into :ID_APPLICATION;

    if (ID_APPLICATION is not null) then
      update APPLICATION A set
        A.ID_APPLICATION_STATUS = :ID_APPLICATION_STATUS_RESET
      where A.ID_APPLICATION = :ID_APPLICATION;
  end
end
^

/* Trigger: APPLICATION_STATUS_BI */
CREATE TRIGGER APPLICATION_STATUS_BI FOR APPLICATION_STATUS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_APPLICATION_STATUS IS NULL) THEN
    NEW.ID_APPLICATION_STATUS = GEN_ID(GEN_APPLICATION_STATUS_ID,1);
END
^

/* Trigger: APPLICATION_TYPE_WORK_BI0 */
CREATE TRIGGER APPLICATION_TYPE_WORK_BI0 FOR APPLICATION_TYPE_WORK
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.ID_PERILOUS is null) then
    select C.ID_PERILOUS
    from CONFIG C
    into new.ID_PERILOUS;
end
^

/* Trigger: CHECK_RESULT_BI */
CREATE TRIGGER CHECK_RESULT_BI FOR CHECK_RESULT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_CHECK_RESULT is null) then
    new.ID_CHECK_RESULT = gen_id(GEN_CHECK_RESULT_ID,1);
end
^

/* Trigger: CONFIG__BI */
CREATE TRIGGER CONFIG__BI FOR CONFIG_
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_CONFIG is null) then
    new.ID_CONFIG = gen_id(GEN_CONFIG__ID,1);

  new.DATE_ = 'now';
end
^

/* Trigger: CUSTOMER_DEBT_BI */
CREATE TRIGGER CUSTOMER_DEBT_BI FOR CUSTOMER_DEBT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_CUSTOMER_DEBT is null) then
    new.ID_CUSTOMER_DEBT = gen_id(GEN_CUSTOMER_DEBT_ID,1);
end
^

/* Trigger: DEPARTMENT_BI */
CREATE TRIGGER DEPARTMENT_BI FOR DEPARTMENT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_DEPARTMENT IS NULL) THEN
    NEW.ID_DEPARTMENT = GEN_ID(GEN_DEPARTMENT_ID,1);
END
^

/* Trigger: DESCRIPTION_TYPE_WORK_BI */
CREATE TRIGGER DESCRIPTION_TYPE_WORK_BI FOR DESCRIPTION_TYPE_WORK
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_DESCRIPTION_TYPE_WORK IS NULL) THEN
    NEW.ID_DESCRIPTION_TYPE_WORK = GEN_ID(GEN_DESCRIPTION_TYPE_WORK_ID,1);
END
^

/* Trigger: EMPLOYEES_BI */
CREATE TRIGGER EMPLOYEES_BI FOR EMPLOYEES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_EMPLOYEES is null) then
    new.ID_EMPLOYEES = gen_id(GEN_EMPLOYEES_ID,1);
end
^

/* Trigger: EXPELLED_BI */
CREATE TRIGGER EXPELLED_BI FOR EXPELLED
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_EXPELLED is null) then
    new.ID_EXPELLED = gen_id(GEN_EXPELLED_ID,1);
end
^

/* Trigger: FOUNDERS_BI */
CREATE TRIGGER FOUNDERS_BI FOR FOUNDERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_FOUNDERS IS NULL) THEN
    NEW.ID_FOUNDERS = GEN_ID(GEN_FOUNDERS_ID,1);
END
^

/* Trigger: FUND_SUM_CONTRACT_BI */
CREATE TRIGGER FUND_SUM_CONTRACT_BI FOR FUND_SUM_CONTRACT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_FUND_SUM_CONTRACT is null) then
    new.ID_FUND_SUM_CONTRACT = gen_id(GEN_FUND_SUM_CONTRACT_ID,1);
end
^

/* Trigger: FUND_SUM_HARM_BI */
CREATE TRIGGER FUND_SUM_HARM_BI FOR FUND_SUM_HARM
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_FUND_SUM_HARM is null) then
    new.ID_FUND_SUM_HARM = gen_id(GEN_FUND_SUM_HARM_ID,1);
end
^

/* Trigger: GROUP_TYPE_WORK_BI */
CREATE TRIGGER GROUP_TYPE_WORK_BI FOR GROUP_TYPE_WORK
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_GROUP_TYPE_WORK IS NULL) THEN
    NEW.ID_GROUP_TYPE_WORK = GEN_ID(GEN_GROUP_TYPE_WORK_ID,1);

  if (NEW.INVISIBLE is null) then
    NEW.INVISIBLE = 0;
END
^

/* Trigger: GROUP_TYPE_WORK_BIU0 */
CREATE TRIGGER GROUP_TYPE_WORK_BIU0 FOR GROUP_TYPE_WORK
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if ((new.CODE <> old.CODE) or (old.CODE is null)) then
    select list(Q.WORD, '.')
    from (
      select lpad(S.WORD, 8, '0') as WORD
      from SENTENCE_TO_TABLE(new.CODE, '.') S
      order by S.INDEX_) as Q
    into new.ORDER_;
end
^

/* Trigger: INFRINGEMENTS_BI */
CREATE TRIGGER INFRINGEMENTS_BI FOR INFRINGEMENTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_INFRINGEMENTS IS NULL) THEN
    NEW.ID_INFRINGEMENTS = GEN_ID(GEN_INFRINGEMENTS_ID,1);
END
^

/* Trigger: INSURANCE_BI */
CREATE TRIGGER INSURANCE_BI FOR INSURANCE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_INSURANCE is null) then
    new.ID_INSURANCE = gen_id(GEN_INSURANCE_ID,1);
end
^

/* Trigger: INSURANCE_SUBJECT_BI */
CREATE TRIGGER INSURANCE_SUBJECT_BI FOR INSURANCE_SUBJECT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_INSURANCE_SUBJECT is null) then
    new.ID_INSURANCE_SUBJECT = gen_id(GEN_INSURANCE_SUBJECT_ID,1);
end
^

/* Trigger: INTERVENTION_BI */
CREATE TRIGGER INTERVENTION_BI FOR INTERVENTION
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_INTERVENTION is null) then
    new.ID_INTERVENTION = gen_id(GEN_INTERVENTION_ID,1);
end
^

/* Trigger: INTERVENTION_BIU0 */
CREATE TRIGGER INTERVENTION_BIU0 FOR INTERVENTION
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.ACTING = 1) then
    update INTERVENTION I set
      I.ACTING = 0
    where I.ID_REGISTER = new.ID_REGISTER;
end
^

/* Trigger: LEGAL_FORM_BI */
CREATE TRIGGER LEGAL_FORM_BI FOR LEGAL_FORM
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_LEGAL_FORM IS NULL) THEN
    NEW.ID_LEGAL_FORM = GEN_ID(GEN_LEGAL_FORM_ID,1);
END
^

/* Trigger: LEVEL_CONTRACTOR_BI */
CREATE TRIGGER LEVEL_CONTRACTOR_BI FOR LEVEL_CONTRACTOR
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_LEVEL_CONTRACTOR is null) then
    new.ID_LEVEL_CONTRACTOR = gen_id(GEN_LEVEL_CONTRACTOR_ID,1);
end
^

/* Trigger: LEVEL_HARM_BI */
CREATE TRIGGER LEVEL_HARM_BI FOR LEVEL_HARM
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_LEVEL_HARM is null) then
    new.ID_LEVEL_HARM = gen_id(GEN_LEVEL_HARM_ID,1);
end
^

/* Trigger: LIMIT_BI */
CREATE TRIGGER LIMIT_BI FOR LIMIT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_LIMIT IS NULL) THEN
    NEW.ID_LIMIT = GEN_ID(GEN_LIMIT_ID,1);
END
^

/* Trigger: MEASURE_BI */
CREATE TRIGGER MEASURE_BI FOR MEASURE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_MEASURE IS NULL) THEN
    NEW.ID_MEASURE = GEN_ID(GEN_MEASURE_ID,1);
END
^

/* Trigger: ORGANIZATION_HISTORY_BI */
CREATE TRIGGER ORGANIZATION_HISTORY_BI FOR ORGANIZATION_HISTORY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_ORGANIZATION_history IS NULL) THEN
    NEW.ID_ORGANIZATION_history = GEN_ID(GEN_ORGANIZATION_history_ID,1);

  NEW.DATE_ = 'NOW';
END
^

/* Trigger: ORGANIZATION_INSURANCE_BI */
CREATE TRIGGER ORGANIZATION_INSURANCE_BI FOR ORGANIZATION_INSURANCE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_ORGANIZATION_INSURANCE is null) then
    new.ID_ORGANIZATION_INSURANCE = gen_id(GEN_ORGANIZATION_INSURANCE_ID,1);
end
^

/* Trigger: ORGANIZATION_ISSUE_BI */
CREATE TRIGGER ORGANIZATION_ISSUE_BI FOR ORGANIZATION_ISSUE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_ORGANIZATION_ISSUE IS NULL) THEN
    NEW.ID_ORGANIZATION_ISSUE = GEN_ID(GEN_ORGANIZATION_ISSUE_ID,1);
END
^

/* Trigger: ORGANIZATION__AU0 */
CREATE TRIGGER ORGANIZATION__AU0 FOR ORGANIZATION_
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if ((new.ID_ORGANIZATION_ISSUE <> old.ID_ORGANIZATION_ISSUE)
    or (new.NAME <> old.NAME)
    or (coalesce(new.SHORT_NAME, '') <> coalesce(old.SHORT_NAME, ''))
    or (new.ADDRESS <> old.ADDRESS)
    or (coalesce(new.ADDRESS_DESCRIPTION, '') <> coalesce(old.ADDRESS_DESCRIPTION, ''))
    or (new.ID_PERSON <> old.ID_PERSON))
  then
    insert into ORGANIZATION_HISTORY (ID_ORGANIZATION_, ID_LEGAL_FORM, ID_ORGANIZATION_ISSUE, NAME, SHORT_NAME, ADDRESS, ADDRESS_DESCRIPTION, OGRN_, INN_, ENTRY_DATE, PHONE, FAX, ID_PERSON, SHARE_CAPITAL, LICENSE, ACCOUNTANT_PHONE, ACCOUNTANT, BIRTH_DATE, EMAIL)
    values(old.ID_ORGANIZATION_, old.ID_LEGAL_FORM, old.ID_ORGANIZATION_ISSUE, old.NAME, old.SHORT_NAME, old.ADDRESS, old.ADDRESS_DESCRIPTION, old.OGRN_, old.INN_, old.ENTRY_DATE, old.PHONE, old.FAX, old.ID_PERSON, old.SHARE_CAPITAL, old.LICENSE, old.ACCOUNTANT_PHONE, old.ACCOUNTANT, old.BIRTH_DATE, old.EMAIL);
end
^

/* Trigger: ORGANIZATION__BI */
CREATE TRIGGER ORGANIZATION__BI FOR ORGANIZATION_
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_ORGANIZATION_ IS NULL) THEN
    NEW.ID_ORGANIZATION_ = GEN_ID(GEN_ORGANIZATION_ID,1);
END
^

/* Trigger: ORGANIZATION__BIU0 */
CREATE TRIGGER ORGANIZATION__BIU0 FOR ORGANIZATION_
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  new.ADDRESS = new.ADDRESS_INDEX || ', ' || new.ADDRESS_COUNTRY || ', ' || (select R.NAME from REGION R where R.ID_REGION = new.ID_REGION)
    || coalesce(', ' || new.ADDRESS_DISTRICT, '') || coalesce(', ' || new.ADDRESS_CITY, '') || coalesce(', ' || new.ADDRESS_AREA, '')
    || coalesce(', ' || new.ADDRESS_STREET, '') || coalesce(', ' || new.ADDRESS_HOUSE, '') || coalesce(', ' || new.ADDRESS_STRUCTURE, '')
    || coalesce(', ' || new.ADDRESS_ROOM, '');
end
^

/* Trigger: PERILOUS_BI */
CREATE TRIGGER PERILOUS_BI FOR PERILOUS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_PERILOUS IS NULL) THEN
    NEW.ID_PERILOUS = GEN_ID(GEN_PERILOUS_ID,1);
END
^

/* Trigger: PERSON_BI */
CREATE TRIGGER PERSON_BI FOR PERSON
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_PERSON IS NULL) THEN
    NEW.ID_PERSON = GEN_ID(GEN_PERSON_ID,1);
END
^

/* Trigger: PROTOCOL_BI */
CREATE TRIGGER PROTOCOL_BI FOR PROTOCOL
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_PROTOCOL IS NULL) THEN
    NEW.ID_PROTOCOL = GEN_ID(GEN_PROTOCOL_ID,1);
END
^

/* Trigger: REGION_BI */
CREATE TRIGGER REGION_BI FOR REGION
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_REGION is null) then
    new.ID_REGION = gen_id(GEN_REGION_ID,1);
end
^

/* Trigger: REGISTER_AD0 */
CREATE TRIGGER REGISTER_AD0 FOR REGISTER
ACTIVE AFTER DELETE POSITION 0
AS
begin
  execute procedure DELETE_REGISTER;
end
^

/* Trigger: REGISTER_BI */
CREATE TRIGGER REGISTER_BI FOR REGISTER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_REGISTER IS NULL) THEN
    NEW.ID_REGISTER = GEN_ID(GEN_REGISTER_ID,1);
END
^

/* Trigger: REGISTER_CHECK_BI */
CREATE TRIGGER REGISTER_CHECK_BI FOR REGISTER_CHECK
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_REGISTER_CHECK is null) then
    new.ID_REGISTER_CHECK = gen_id(GEN_REGISTER_CHECK_ID,1);
end
^

/* Trigger: REGISTER_CHECK_BIU0 */
CREATE TRIGGER REGISTER_CHECK_BIU0 FOR REGISTER_CHECK
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.ACTING = 1) then
    update REGISTER_CHECK RC set
      RC.ACTING = 0
    where RC.ID_REGISTER = new.ID_REGISTER;
end
^

/* Trigger: RIGHT__AIU0 */
CREATE TRIGGER RIGHT__AIU0 FOR RIGHT_
ACTIVE AFTER INSERT OR UPDATE POSITION 0
AS
  declare variable ID_APPLICATION_STATUS_RESET int;
  declare variable ID_APPLICATION_STATUS_ACTIVE int;
begin
  ID_APPLICATION_STATUS_RESET = null;
  ID_APPLICATION_STATUS_ACTIVE = null;
  select C.ID_APPLICATION_STATUS_ACTIVE, C.ID_APPLICATION_STATUS_RESET
  from CONFIG C
  into :ID_APPLICATION_STATUS_ACTIVE, :ID_APPLICATION_STATUS_RESET;

  if ((coalesce(old.ID_APPLICATION_STATUS, 0) <> new.ID_APPLICATION_STATUS)
    and (new.ID_APPLICATION_STATUS = ID_APPLICATION_STATUS_ACTIVE))
  then
    update RIGHT_ R set
      R.ID_APPLICATION_STATUS = :ID_APPLICATION_STATUS_RESET
    where R.ID_REGISTER = new.ID_REGISTER and R.ID_RIGHT <> new.ID_RIGHT;
end
^

/* Trigger: RIGHT__AIUD0 */
CREATE TRIGGER RIGHT__AIUD0 FOR RIGHT_
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
  declare variable ID_REGISTER int;
begin
  if (deleting) then
    ID_REGISTER = old.ID_REGISTER;
  else
    ID_REGISTER = new.ID_REGISTER;

  update REGISTER R set
    R.ID_RIGHT = (select LR.ID_RIGHT from LAST_RIGHT(R.CODE) LR)
  where R.ID_REGISTER = :ID_REGISTER;
end
^

/* Trigger: RIGHT__BI */
CREATE TRIGGER RIGHT__BI FOR RIGHT_
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_RIGHT is null) then
    new.ID_RIGHT = gen_id(GEN_RIGHT__ID,1);
end
^

/* Trigger: RIGHT__BIU0 */
CREATE TRIGGER RIGHT__BIU0 FOR RIGHT_
ACTIVE BEFORE INSERT POSITION 0
AS
  declare variable REG_CODE int;
begin
  REG_CODE = null;
  select R.CODE
  from REGISTER R
  where R.ID_REGISTER = new.ID_REGISTER
  into :REG_CODE;

  if (REG_CODE is null) then
  begin
    REG_CODE = GEN_ID(GEN_REGISTER_CODE,1);

    update REGISTER R set
      R.CODE = :REG_CODE
    where R.ID_REGISTER = new.ID_REGISTER;
  end
end
^

/* Trigger: SCOPE_WORK_BI */
CREATE TRIGGER SCOPE_WORK_BI FOR SCOPE_WORK
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_SCOPE_WORK is null) then
    new.ID_SCOPE_WORK = gen_id(GEN_SCOPE_WORK_ID,1);
end
^

/* Trigger: TYPE_CHECK_BI */
CREATE TRIGGER TYPE_CHECK_BI FOR TYPE_CHECK
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID_TYPE_CHECK is null) then
    new.ID_TYPE_CHECK = gen_id(GEN_TYPE_CHECK_ID,1);
end
^

/* Trigger: TYPE_WORK_BI */
CREATE TRIGGER TYPE_WORK_BI FOR TYPE_WORK
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_TYPE_WORK IS NULL) THEN
    NEW.ID_TYPE_WORK = GEN_ID(GEN_TYPE_WORK_ID,1);
END
^

/* Trigger: TYPE_WORK_BIU0 */
CREATE TRIGGER TYPE_WORK_BIU0 FOR TYPE_WORK
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if ((new.CODE <> old.CODE) or (old.CODE is null))  then
    select list(Q.WORD, '.')
    from (
      select lpad(S.WORD, 8, '0') as WORD
      from SENTENCE_TO_TABLE(new.CODE, '.') S
      order by S.INDEX_) as Q
    into new.ORDER_;
end
^

/* Trigger: VERIFICATION_BI */
CREATE TRIGGER VERIFICATION_BI FOR VERIFICATION
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID_VERIFICATION IS NULL) THEN
    NEW.ID_VERIFICATION = GEN_ID(GEN_VERIFICATION_ID,1);
END
^
SET TERM ; ^



/******************************************************************************/
/***                           Stored procedures                            ***/
/******************************************************************************/



SET TERM ^ ;

ALTER PROCEDURE BASE$CHANGE_CASE (
    FIO TLONG_NAME)
RETURNS (
    NAME TLONG_NAME,
    SNAME TLONG_NAME,
    PNAME TLONG_NAME)
AS
declare variable LENGTH_ integer;
declare variable LAST_CHAR char(10);
begin
  LENGTH_ = position(' ', :FIO) - 1;
  if (:LENGTH_ > 0) then
  begin
    SNAME = substring(:FIO from 1 for :LENGTH_);
    FIO = substring(:FIO from :LENGTH_ + 2 for char_length(:FIO) - :LENGTH_ - 1);

    LENGTH_ = position(' ', :FIO) - 1;
    if (:LENGTH_ > 0) then
    begin
      NAME = substring(:FIO from 1 for :LENGTH_);
      PNAME = substring(:FIO from :LENGTH_ + 2 for char_length(:FIO) - :LENGTH_ - 1);
    end
  end

-------- NAME

  if (:NAME is not null) then
  begin
    LENGTH_ = char_length(:NAME);
    LAST_CHAR = lower(substring(:NAME from :LENGTH_ for 1));
  
    if ((LAST_CHAR = '') or (LAST_CHAR = 'a')) then
      NAME = substring(:NAME from 1 for :LENGTH_ - 1) || '';
  
    if (LAST_CHAR = '') then
      NAME = substring(:NAME from 1 for :LENGTH_ - 1) || '';
  
    if ((LAST_CHAR = '') or (LAST_CHAR = '') or (LAST_CHAR = '') or (LAST_CHAR = '')) then
      NAME = :NAME || '';
  end

-------- SNAME

  if (:SNAME is not null) then
  begin
    LENGTH_ = char_length(:SNAME);
    LAST_CHAR = lower(substring(:SNAME from :LENGTH_ for 1));
  
    if ((:LAST_CHAR = '') or (:LAST_CHAR = '') or (:LAST_CHAR = '') or (:LAST_CHAR = '')) then
      SNAME = :SNAME || '';
  
    if (:LAST_CHAR = '') then
      SNAME = substring(:SNAME from 1 for :LENGTH_ - 1) || '';
  
    if (:LAST_CHAR = '') then
      SNAME = substring(:SNAME from 1 for :LENGTH_ - 2) || '';
  
    if (:LAST_CHAR = '') then
      SNAME = substring(:SNAME from 1 for :LENGTH_ - 2) || '';
  end

-------- PNAME

  if (:PNAME is not null) then
  begin
    LENGTH_ = char_length(:PNAME);
    LAST_CHAR = lower(substring(:PNAME from :LENGTH_ for 1));
  
    if (:LAST_CHAR = '') then
      PNAME = substring(:PNAME from 1 for :LENGTH_ - 1) || '';
  
    if (:LAST_CHAR = '') then
      PNAME = :PNAME || '';
  end

  suspend;
end^


ALTER PROCEDURE BASE$EXECUTE_STATEMENT (
    SQL TDESCRIPTION)
RETURNS (
    RESULT INTEGER)
AS
begin
  execute statement :SQL;

  RESULT = 0;
  suspend;
end^


ALTER PROCEDURE BASE$FIRST_LAST_DAY_IN_MONTH (
    DATE_ DATE)
RETURNS (
    FIRST_DAY DATE,
    LAST_DAY DATE)
AS
begin
  FIRST_DAY = :DATE_ - extract(day from :DATE_) + 1;
  LAST_DAY = :DATE_ - extract(day from :DATE_) + 32 - extract(day from :DATE_ - extract(day from :DATE_) + 32);

  suspend;
end^


ALTER PROCEDURE BASE$FOR_INT (
    FINISH_VALUE TID,
    START_VALUE TID = 0)
RETURNS (
    I TID)
AS
begin
  I = START_VALUE;

  while (I <= FINISH_VALUE) do
  begin
    suspend;

    I = I + 1;
  end
end^


ALTER PROCEDURE CONFIG (
    DATE_NOW TDATE = '01.01.2100')
RETURNS (
    ID_CONFIG TID,
    DATE_ TDATE,
    LONG_NAME TLONG_NAME,
    LONG_NAME2 TLONG_NAME,
    SHORT_NAME TNAME,
    NAME TLONG_NAME,
    CODE TNAME,
    NUMBER TID,
    ADDRESS TDESCRIPTION,
    SHORT_ADDRESS TLONG_NAME,
    PHONE TNAME,
    COUNT_BANK TNAME,
    INN TNAME,
    KPP TNAME,
    BANK_NAME TDESCRIPTION,
    BANK_BIK TNAME,
    BANK_COUNT TNAME,
    COUNT_NUMBER_ TID,
    ID_APPLICATION_STATUS_RESET TID,
    EMAIL TLONG_NAME,
    ID_PERILOUS TID,
    ID_APPLICATION_STATUS_END TID,
    ID_APPLICATION_STATUS_ACTIVE TID,
    ID_APPLICATION_STATUS_SUSPENDED TID,
    ID_REGION TID)
AS
begin
  select ID_CONFIG, DATE_, LONG_NAME, LONG_NAME2, SHORT_NAME, NAME, CODE, NUMBER, ADDRESS, SHORT_ADDRESS, PHONE, COUNT_BANK, INN, KPP, BANK_NAME, BANK_BIK, BANK_COUNT, COUNT_NUMBER_, ID_APPLICATION_STATUS_RESET, EMAIL, ID_PERILOUS, ID_APPLICATION_STATUS_END, ID_APPLICATION_STATUS_ACTIVE, ID_APPLICATION_STATUS_SUSPENDED, ID_REGION
  from CONFIG_
  where DATE_ <= :DATE_NOW
  order by DATE_ desc
  rows 1
  into ID_CONFIG, DATE_, LONG_NAME, LONG_NAME2, SHORT_NAME, NAME, CODE, NUMBER, ADDRESS, SHORT_ADDRESS, PHONE, COUNT_BANK, INN, KPP, BANK_NAME, BANK_BIK, BANK_COUNT, COUNT_NUMBER_, ID_APPLICATION_STATUS_RESET, EMAIL, ID_PERILOUS, ID_APPLICATION_STATUS_END, ID_APPLICATION_STATUS_ACTIVE, ID_APPLICATION_STATUS_SUSPENDED, ID_REGION;

  suspend;
end^


ALTER PROCEDURE DATA_GET_NUMBER (
    CODE TID,
    DATE_ TDATE)
RETURNS (
    NUMBER TLONG_NAME)
AS
begin
    select
      'C-' || lpad(CON.NUMBER, 3, '0')
      || '-' || lpad(R_SELF.CODE, 2, '0')
      || '-' || lpad(REG.CODE, 4, '0')
      || '-' || lpad(R_ORG.CODE, 2, '0')
      || '-' || D.RESULT
    from REGISTER REG
    left join ORGANIZATION_ O on O.ID_ORGANIZATION_ = REG.ID_ORGANIZATION_
    left join CONFIG CON on 0=0
    left join REGION R_SELF on R_SELF.ID_REGION = CON.ID_REGION
    left join REGION R_ORG on R_ORG.ID_REGION = O.ID_REGION
    left join DATE_TIME_TO_STR(:DATE_, 'DDMMYY') D on 0=0
    where REG.CODE = :CODE and :DATE_ is not null
    into :NUMBER;
    
    suspend;
end^


ALTER PROCEDURE DATE_TIME_TO_STR (
    DATE_TIME TDATETIME,
    FORMAT TDATETIME_VARCHAR = 'DD.MM.YYYY HH:NN:SS.ZZZ')
RETURNS (
    RESULT TDATETIME_VARCHAR)
AS
declare variable YEAR_ integer;
declare variable Y_ integer;
declare variable MONTH_ integer;
declare variable DAY_ integer;
declare variable HOUR_ integer;
declare variable MINUTE_ integer;
declare variable SECOND_ integer;
declare variable MILLISECOND_ integer;
begin
  /*
  yyyy - 
  yy - 
  mm - 
  dd - 

  hh - 
  nn - 
  ss - 
  zzz - 
  */
  if (:DATE_TIME is not null) then
  begin
    YEAR_ = extract(year from DATE_TIME);
    Y_ = mod(YEAR_, 100);
    MONTH_ = extract(month from DATE_TIME);
    DAY_ = extract(day from DATE_TIME);
    HOUR_ = extract(hour from DATE_TIME);
    MINUTE_ = extract(minute from DATE_TIME);
    SECOND_ = extract(second from DATE_TIME);
    MILLISECOND_ = extract(millisecond from DATE_TIME);
  
    RESULT = FORMAT;
  
    RESULT = replace(RESULT, 'YYYY', coalesce(iif(YEAR_ < 10, 0, null), '') || coalesce(iif(YEAR_ < 100, 0, null), '')
      || coalesce(iif(YEAR_ < 1000, 0, null), '') || YEAR_);
    RESULT = replace(RESULT, 'YY', coalesce(iif(YEAR_ < 10, 0, null), '') || Y_);
    RESULT = replace(RESULT, 'MM', coalesce(iif(MONTH_ < 10, 0, null), '') || MONTH_);
    RESULT = replace(RESULT, 'DD', coalesce(iif(DAY_ < 10, 0, null), '') || DAY_);
    RESULT = replace(RESULT, 'HH', coalesce(iif(HOUR_ < 10, 0, null), '') || HOUR_);
    RESULT = replace(RESULT, 'NN', coalesce(iif(MINUTE_ < 10, 0, null), '') || MINUTE_);
    RESULT = replace(RESULT, 'SS', coalesce(iif(SECOND_ < 10, 0, null), '') || SECOND_);
    RESULT = replace(RESULT, 'ZZZ', coalesce(iif(MILLISECOND_ < 10, 0, null), '') || coalesce(iif(MILLISECOND_ < 100, 0, null), '') || MILLISECOND_);
  end

  suspend;
end^


ALTER PROCEDURE DELETE_REGISTER
AS
begin
  execute statement 'ALTER SEQUENCE GEN_REGISTER_CODE RESTART WITH ' || (select max(R.CODE) from REGISTER R);
end^


ALTER PROCEDURE FLOAT_TO_STR (
    FLOAT_ TQUANTITY,
    DIGITS TID = 2)
RETURNS (
    RESULT TSHORT_NAME)
AS
declare variable DOT_INDEX TID;
begin
  RESULT = FLOAT_;
  DOT_INDEX = position('.' in RESULT);

  if (DOT_INDEX <> 0) then
    RESULT = substring(RESULT from 1 for DOT_INDEX + iif(DIGITS = 0, -1, DIGITS));
  else
    if (DIGITS <> 0) then
      RESULT = RESULT || lpad('.', DIGITS, '0');

  suspend;
end^


ALTER PROCEDURE GET_CURRENCYSTR (
    VAL NUMERIC(15,2),
    SHOWCURRENCY INTEGER = 1)
RETURNS (
    RESULT TSHORT_DESCRIPTION)
AS
declare variable RAZRYAD varchar(50);
declare variable RAZRYAD_IDX varchar(28);
declare variable HUNDREDS varchar(64);
declare variable HUNDREDS_IDX varchar(30);
declare variable TENS varchar(69);
declare variable TENS_IDX varchar(40);
declare variable ONES varchar(138);
declare variable ONES_IDX varchar(100);
declare variable SIGN_OF_VAL varchar(6);
declare variable RAZ integer;
declare variable CENTS varchar(3);
declare variable VAL_STR varchar(20);
declare variable NUM varchar(20);
declare variable I integer;
declare variable BUF varchar(200);
declare variable BUF1 varchar(200);
BEGIN
  /*  */
  razryad_idx = /* 2.2 */ '0100010506071308210829114011';
  razryad = '';
  hundreds_idx = /* 2.1 */ '010013046106169257328407479569';
  hundreds = '';
  tens_idx = /* 2.2 */ '0100010001080908170522093110410950116109';
  tens = '';
  ones_idx = /* 3.2 */ '0010000100001000010300406010040140501904023060290603506041110521006210072120841009411105101151212712';
  ones = '';
 
  IF (ShowCurrency IS NULL) then ShowCurrency = 0;
  RESULT = '';
 
  /*   */
  IF (val < 0) then begin
    sign_of_val = ' ';
    val = -val;
  end else
    sign_of_val = '';
 
  /*    ,     */
  val_str = cast(val AS varchar(20));
  i = position('.' IN val_str);
  cents = lpad(substring(val_str FROM i+1 FOR 2), 2, '0');
  val_str = lpad(substring(val_str FROM 1 FOR i-1), ((i+1)/3*3), '0');
 
  /*   */
  raz = 0; RESULT = '';
  while (val_str != '') do begin
    /*    */
    num = RIGHT(val_str, 3);
    /*     */
    IF (num != '000') then begin
      /*   */
      i = cast(substring(num FROM 1 FOR 1) AS int);
      buf = substring(hundreds FROM cast(substring(hundreds_idx FROM i*3+1 FOR 2) AS int) FOR cast(substring(hundreds_idx FROM i*3+3 FOR 1) AS int));
 
      /*   */
      /*  ""   */
      IF (substring(num FROM 2 FOR 1) = '1') then begin
          /*   "" */
          i = cast(substring(num FROM 2 FOR 2) AS int);
          buf1 = substring(ones FROM cast(substring(ones_idx FROM i*5+1 FOR 3) AS int) FOR cast(substring(ones_idx FROM i*5+4 FOR 2) AS int));
          IF (buf != '') then buf = buf || ' ';
          buf = buf || buf1;
      end else
      /*  ""    */
      begin
        /*  */
        i = cast(substring(num FROM 2 FOR 1) AS int);
        buf1 = substring(tens FROM cast(substring(tens_idx FROM i*4+1 FOR 2) AS int) FOR cast(substring(tens_idx FROM i*4+3 FOR 2) AS int));
        IF (buf != '' AND buf1 != '') then buf = buf || ' ';
        buf = buf || buf1;
 
        /*  */
        i = cast(substring(num FROM 3 FOR 1) AS int);
        /*      */
        IF (i = 1) then begin
          IF (raz = 1) then buf1 = ''; else buf1 = '';
        end else
        IF (i = 2) then begin
          IF (raz = 1) then buf1 = ''; else buf1 = '';
        end else
          buf1 = substring(ones FROM cast(substring(ones_idx FROM i*5+1 FOR 3) AS int) FOR cast(substring(ones_idx FROM i*5+4 FOR 2) AS int));
        IF (buf != '' AND buf1 != '') then buf = buf || ' ';
        buf = buf || buf1;
      end
 
      /*   */
      buf1 = substring(razryad FROM cast(substring(razryad_idx FROM raz*4+1 FOR 2) AS int) FOR cast(substring(razryad_idx FROM raz*4+3 FOR 2) AS int));
      IF (buf1 != '') then begin
        /*     */
        IF (i = 1) then begin
          IF (raz = 1) then buf1 = buf1 || '';
        end else
        IF (i IN (2,3,4)) then begin
          IF (raz = 1) then buf1 = buf1 || '';
          else IF (raz > 1) then buf1 = buf1 || '';
        end else
          IF (raz > 1) then buf1 = buf1 || '';
        buf = buf || ' ' || buf1;
      end
    end else
      buf = '';
 
    /*      */
    IF (RESULT != '' AND buf != '') then buf = buf || ' ';
    RESULT = buf || RESULT;
    /*     */
    val_str = LEFT(val_str, char_length(val_str)-3);
    /*    */
    raz = raz + 1;
  end
 
  /*   */
  RESULT = sign_of_val || RESULT;
  /*     */
  RESULT = upper(substring(RESULT FROM 1 FOR 1)) || substring(RESULT FROM 2);
 
  /*  "  " */
  IF (ShowCurrency = 1) then
    RESULT = RESULT || ' . ' || cents || ' .';
 
  suspend;
end^


ALTER PROCEDURE GET_INDEX_LIST (
    SQL TDESCRIPTION)
RETURNS (
    INDEX_ TID,
    ID TID,
    NAME TLONG_NAME)
AS
begin
  INDEX_ = 0;

  for execute statement :SQL
  into :ID, :NAME do
  begin
    INDEX_ = INDEX_ + 1;

    suspend;
  end
end^


ALTER PROCEDURE GET_REGISTER_HASH (
    ALL_REGISTER TBOOLEAN = 0,
    UPDATE_REGISTER TBOOLEAN = 1)
RETURNS (
    ID_REGISTER TID)
AS
declare variable CURRENT_HASH_ TNAME;
begin
  for select Q.ID_REGISTER, Q.CURRENT_HASH_
  from (select R.ID_REGISTER,
    hash(L.LONG_NAME || O.NAME || O.ADDRESS || O.OGRN_ || O.INN_
      || O.ENTRY_DATE || O.PHONE || coalesce(O.SHARE_CAPITAL, '')
      || P.NAME || P.SNAME || P.PNAME || coalesce(O.SHORT_NAME, '') || coalesce(O.EMAIL, '') || coalesce(P.BIRTH_DATE, '')
      || coalesce((select list(F.SHARE_CAPITAL || coalesce(F.ID_PERSON, '') || coalesce(F.ID_ORGANIZATION__, ''))
                   from FOUNDERS F
                   where F.ID_ORGANIZATION_ = O.ID_ORGANIZATION_), '')
      || coalesce((select list(ATW.ID_TYPE_WORK || ATW.ALLOWED || coalesce(ATW.ID_PERILOUS, '') || coalesce(ATW.ID_DESCRIPTION, ''))
                   from APPLICATION_TYPE_WORK ATW
                   where ATW.ID_APPLICATION = LA.ID_APPLICATION), '')
      || coalesce((select list(V.DESCRIPTION) from VERIFICATION V where V.ID_REGISTER = R.ID_REGISTER), '')) as CURRENT_HASH_
    from REGISTER R
    left join ORGANIZATION_ O on O.ID_ORGANIZATION_ = R.ID_ORGANIZATION_
    left join LEGAL_FORM L on L.ID_LEGAL_FORM = O.ID_LEGAL_FORM
    left join PERSON P on P.ID_PERSON = O.ID_PERSON
    left join LAST_APPLICATION(R.ID_REGISTER) LA on 0=0
    where R.CODE is not null) Q
   where :ALL_REGISTER = 1
      or exists(select 1
                 from REGISTER R_
                 where R_.ID_REGISTER = Q.ID_REGISTER
                   and coalesce(R_.HASH_, '0') <> Q.CURRENT_HASH_)

  into :ID_REGISTER, :CURRENT_HASH_ do
  begin
    if (:UPDATE_REGISTER = 1) then
      update REGISTER R set
        R.HASH_ = :CURRENT_HASH_
      where R.ID_REGISTER = :ID_REGISTER;

    suspend;
  end
end^


ALTER PROCEDURE GET_TREE (
    PARENT_VALUE TID,
    TABLE_NAME TNAME NOT NULL,
    FIELD_ID TNAME NOT NULL,
    FIELD_NAME TNAME NOT NULL,
    FIELD_PARENT TNAME NOT NULL,
    FIELD_ORDER TNAME,
    PREFIX TNAME NOT NULL)
RETURNS (
    ID TID,
    NAME TLONG_NAME,
    PARENT TID)
AS
begin
  for execute statement 'select ' || :FIELD_ID || ',' || :FIELD_NAME
    || ',' || :FIELD_PARENT || ' from ' || :TABLE_NAME
    || ' where ' || :FIELD_PARENT || coalesce('=' || :PARENT_VALUE, ' is null')
    || coalesce(' order by ' || :FIELD_ORDER, '')
  into :ID, :NAME, :PARENT do
  begin
    suspend;

    for select GT.ID, :PREFIX || GT.NAME, GT.PARENT
    from GET_TREE(:ID, :TABLE_NAME, :FIELD_ID, :FIELD_NAME, :FIELD_PARENT, :FIELD_ORDER, :PREFIX) GT
    into :ID, :NAME, :PARENT do
      suspend;
  end
end^


ALTER PROCEDURE GET_WORD (
    STR TDESCRIPTION,
    SEPARATOR TVERY_SHORT_NAME = ',',
    INDEX_ TID = 1)
RETURNS (
    WORD TLONG_NAME)
AS
declare variable CHAR_ TCHAR;
declare variable I TID;
declare variable STEP TID;
declare variable LAST_I TID;
declare variable LEN TID;
begin
  LEN = char_length(STR);
  I = 1;
  LAST_I = 1;
  STEP = 0;

  while (LEN >= I) do
  begin
    CHAR_ = substring(STR from I for 1);

    if (CHAR_ = SEPARATOR) then
    begin
      STEP = STEP + 1 ;

      if (STEP = INDEX_) then
      begin
        WORD = substring(STR from LAST_I for I - LAST_I);
        break;
      end

      LAST_I = I + 1;
    end

    I = I + 1;
  end

  if ((I - 1 = LEN) and (STEP + 1 = INDEX_)) then
    WORD = substring(STR from LAST_I for I - LAST_I);

  suspend;
end^


ALTER PROCEDURE LAST_APPLICATION (
    REG_CODE TID,
    DATE_ TDATE = '01.01.2100')
RETURNS (
    ID_APPLICATION TID,
    CREATE_DATE TDATE,
    DECISION_DATE TDATE,
    NUMBER TSHORT_NAME,
    ID_ORGANIZATION_ TID,
    ID_PROTOCOL TID,
    CERTIFICATE TLONG_NAME,
    ID_APPLICATION_STATUS TID,
    STATUS_DATE TDATE)
AS
begin
  select A.ID_APPLICATION, A.CREATE_DATE, P.DECISION_DATE, P.NUMBER, RG.ID_ORGANIZATION_, P.ID_PROTOCOL, A.CERTIFICATE,
    A.ID_APPLICATION_STATUS, A.STATUS_DATE
  from APPLICATION A
  left join REGISTER RG on RG.ID_REGISTER = A.ID_REGISTER
  left join PROTOCOL P on P.ID_PROTOCOL = A.ID_PROTOCOL
  where RG.CODE = :REG_CODE and P.DECISION_DATE <= :DATE_
  order by P.DECISION_DATE desc
  rows 1
  into :ID_APPLICATION, :CREATE_DATE, :DECISION_DATE, :NUMBER, :ID_ORGANIZATION_, :ID_PROTOCOL, :CERTIFICATE,
    :ID_APPLICATION_STATUS, :STATUS_DATE;

  if (row_count > 0) then
    suspend;
end^


ALTER PROCEDURE LAST_RIGHT (
    REG_CODE TID,
    DATE_ TDATE = '01.01.2100')
RETURNS (
    ID_RIGHT TID,
    DECISION_DATE TDATE,
    NUMBER TSHORT_NAME,
    ID_ORGANIZATION_ TID,
    ID_PROTOCOL TID,
    ID_PERILOUS TID,
    ID_APPLICATION_STATUS TID)
AS
begin
  select R.ID_RIGHT, P.DECISION_DATE, P.NUMBER, RG.ID_ORGANIZATION_, R.ID_PROTOCOL,
    R.ID_PERILOUS, R.ID_APPLICATION_STATUS
  from RIGHT_ R
  left join REGISTER RG on RG.ID_REGISTER = R.ID_REGISTER
  left join PROTOCOL P on P.ID_PROTOCOL = R.ID_PROTOCOL
  where RG.CODE = :REG_CODE and P.DECISION_DATE <= :DATE_
  order by P.DECISION_DATE desc
  rows 1
  into :ID_RIGHT, :DECISION_DATE, :NUMBER, :ID_ORGANIZATION_, :ID_PROTOCOL,
    :ID_PERILOUS, :ID_APPLICATION_STATUS;

  if (row_count > 0) then
    suspend;
end^


ALTER PROCEDURE LAST_STATUS (
    CODE TID)
RETURNS (
    ID_PROTOCOL TID,
    NUMBER TSHORT_NAME,
    DECISION_DATE TDATE,
    ID_APPLICATION_STATUS TID,
    ID_PERILOUS TID,
    PERILOUS_INDEX TID)
AS
begin
  select P.ID_PROTOCOL, P.NUMBER, P.DECISION_DATE, coalesce(R.ID_APPLICATION_STATUS, A.ID_APPLICATION_STATUS),
    PR.ID_PERILOUS, PR.INDEX_
  from REGISTER RG
  left join APPLICATION A on A.ID_APPLICATION = RG.ID_APPLICATION
  left join RIGHT_ R on R.ID_RIGHT = RG.ID_RIGHT
  left join PROTOCOL P on P.ID_PROTOCOL = coalesce(R.ID_PROTOCOL, A.ID_PROTOCOL)
  left join PERILOUS PR on PR.ID_PERILOUS = R.ID_PERILOUS
  where RG.CODE = :CODE
  into :ID_PROTOCOL, :NUMBER, :DECISION_DATE, :ID_APPLICATION_STATUS, :ID_PERILOUS, :PERILOUS_INDEX;

  if (ID_PERILOUS is null) then
  begin
    with
      APPLICATION_PERILOUS as (
        select max(P.INDEX_) as INDEX_
        from REGISTER RG
        left join APPLICATION_TYPE_WORK ATW on ATW.ID_APPLICATION = RG.ID_APPLICATION and ATW.ALLOWED = 1
        left join PERILOUS P on P.ID_PERILOUS = ATW.ID_PERILOUS
        where RG.CODE = :CODE
      )

    select P.ID_PERILOUS, AP.INDEX_
    from APPLICATION_PERILOUS AP
    left join PERILOUS P on P.INDEX_ = AP.INDEX_
    into :ID_PERILOUS, :PERILOUS_INDEX;
  end

  suspend;
end^


ALTER PROCEDURE MONTH_LIST (
    END_ TID = 1,
    SELECT_ TID = 0)
RETURNS (
    INDEX_ TID,
    NAME_ TNAME)
AS
begin
  INDEX_ = SELECT_;
  NAME_ = '';

  while (INDEX_ <= 12) do
  begin
    if (INDEX_ = 1) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 2) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 3) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 4) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 5) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 6) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 7) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 8) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 9) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 10) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 11) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (INDEX_ = 12) then
      NAME_ = '' || iif(END_ = 1, '', '');

    if (NAME_ <> '') then
      suspend;

    INDEX_ = INDEX_ + 1;

    if (SELECT_ <> 0) then
      exit;
  end
end^


ALTER PROCEDURE NAME_TO_FIELDS (
    NAME TLONG_NAME)
RETURNS (
    L_NAME TLONG_NAME,
    F_NAME TLONG_NAME,
    M_NAME TLONG_NAME)
AS
begin
  L_NAME = '';
  F_NAME = '';
  M_NAME = '';

  if (NAME is not null) then
  begin
    select L.WORD, F.WORD, M.WORD
    from
      (select list(S.WORD, ' ') as NAME
       from SENTENCE_TO_TABLE(:NAME,  ' ') S
       where S.WORD <> '') B
    left join SENTENCE_TO_TABLE(B.NAME,  ' ') L on L.INDEX_ = 1
    left join SENTENCE_TO_TABLE(B.NAME,  ' ') F on F.INDEX_ = 2
    left join SENTENCE_TO_TABLE(B.NAME,  ' ') M on M.INDEX_ = 3
    into :L_NAME, :F_NAME,  :M_NAME;

    if (M_NAME is null) then
    begin
      F_NAME = '';
      M_NAME = '';
    end
  end

  suspend;
end^


ALTER PROCEDURE NAME_TO_SHORT (
    NAME TLONG_NAME,
    SNAME TLONG_NAME,
    PNAME TLONG_NAME)
RETURNS (
    RESULT TLONG_NAME)
AS
begin
  RESULT = :SNAME || coalesce(' ' || substring(:NAME from 1 for 1) || '.', '') || coalesce(' ' || substring(:PNAME from 1 for 1) || '.', '');

  suspend;
end^


ALTER PROCEDURE NUMBERS_FROM_STRING (
    STR TSHORT_DESCRIPTION)
RETURNS (
    RESULT TQUANTITY)
AS
declare variable CHAR_ TCHAR;
declare variable COUNT_ TCOUNT;
declare variable I TCOUNT;
declare variable VALUE_ TSHORT_DESCRIPTION;
begin
  VALUE_ = '';
  COUNT_ = char_length(STR);
  I = 1;

  while (COUNT_ >= I) do
  begin
    CHAR_ = substring(STR from I for 1);

    if (position(CHAR_, '0123456789') > 0) then
      VALUE_ = VALUE_ || CHAR_;

    I = I + 1;
  end

  if (char_length(STR) > 0) then
    RESULT = cast(VALUE_ as TQUANTITY);

  suspend;
end^


ALTER PROCEDURE SENTENCE_TO_TABLE (
    STR TDESCRIPTION,
    SEPARATOR TVERY_SHORT_NAME = ',')
RETURNS (
    WORD TLONG_NAME,
    INDEX_ INTEGER)
AS
declare variable SENTENCE_LEN TID;
declare variable SEPARATOR_LEN TID;
declare variable I TID;
declare variable LAST_I TID;
declare variable SEPARATOR_ TVERY_SHORT_NAME;
begin
  SENTENCE_LEN = char_length(STR);
  SEPARATOR_LEN = char_length(SEPARATOR);

  I = 1;
  LAST_I = 1;
  INDEX_ = 1;

  while (SENTENCE_LEN > (I + SEPARATOR_LEN - 2)) do
  begin
    SEPARATOR_ = substring(STR from I for SEPARATOR_LEN);

    if (SEPARATOR_ = SEPARATOR) then
    begin
      WORD = substring(STR from LAST_I for I - LAST_I);

      suspend;

      INDEX_ = INDEX_ + 1;
      LAST_I = I + SEPARATOR_LEN;
    end

    I = I + 1;
  end

  if (LAST_I <= SENTENCE_LEN) then
  begin
    WORD = substring(STR from LAST_I for SENTENCE_LEN - LAST_I + 1);
    suspend;
  end
end^


ALTER PROCEDURE SET_CONFIG_COUNT_NUMBER_ (
    COUNT_NUMBER_ INTEGER)
RETURNS (
    NEW_COUNT_NUMBER_ INTEGER)
AS
begin
  NEW_COUNT_NUMBER_ = COUNT_NUMBER_ + 1;

  update CONFIG_ CON_ set
    CON_.COUNT_NUMBER_ = :NEW_COUNT_NUMBER_
  where CON_.ID_CONFIG in (select CON.ID_CONFIG from CONFIG CON);

  suspend;
end^


ALTER PROCEDURE STR_TO_JSON (
    STR TMIDDLE_DESCRIPTION)
RETURNS (
    RESULT TMIDDLE_DESCRIPTION)
AS
begin
  if (STR is not null) then
  begin
    RESULT = :STR;
    
    RESULT = replace(:RESULT, ascii_char(10), '\n');
    RESULT = replace(:RESULT, ascii_char(13), '\r');
    RESULT = replace(:RESULT, '\', '\\');
    RESULT = replace(:RESULT, '"', '\"');

    suspend;
  end
end^


ALTER PROCEDURE STR_TO_XML (
    STR TMIDDLE_DESCRIPTION)
RETURNS (
    RESULT TMIDDLE_DESCRIPTION)
AS
begin
  if (STR is not null) then
  begin
    RESULT = :STR;
    
    RESULT = replace(:RESULT, '&', '&amp;');
    RESULT = replace(:RESULT, '<', '&lt;');
    RESULT = replace(:RESULT, '>', '&gt;');
    RESULT = replace(:RESULT, '''', '&apos;');
    RESULT = replace(:RESULT, '"', '&quot;');

    suspend;
  end
end^


ALTER PROCEDURE USER$CUSTOMER_DEBT (
    LINE TLONG_DESCRIPTION)
AS
declare variable NUMBER integer;
declare variable ID integer;
declare variable ROW TNAME;
declare variable YEAR_ integer;
declare variable Q1 integer;
declare variable Q2 integer;
declare variable Q3 integer;
declare variable Q4 integer;
declare variable EXTRA_ integer;
declare variable CONST_VAR TNAME = 'USER_TRANSACTION';
declare variable CONST_ID TNAME = 'CURRENT_ID';
begin
  with
    BASE as (
      select S.INDEX_, replace(S.WORD, ' ', '') as WORD
      from SENTENCE_TO_TABLE(:LINE, ';') S)

  select
    --iif(B_NUMBER.WORD similar TO '[0-9]+', 1, 0),
    iif(B_NUMBER.WORD similar to '[0-9]+', cast(B_NUMBER.WORD as int), null),

    R.ID_REGISTER,
    B_ROW.WORD,

    iif(B_Y.WORD similar to '[0-9]+', cast(B_Y.WORD as int), 0),
    iif(B_Q1.WORD similar to '[0-9]+', cast(B_Q1.WORD as int), 0),
    iif(B_Q2.WORD similar to '[0-9]+', cast(B_Q2.WORD as int), 0),
    iif(B_Q3.WORD similar to '[0-9]+', cast(B_Q3.WORD as int), 0),
    iif(B_Q4.WORD similar to '[0-9]+', cast(B_Q4.WORD as int), 0),
    iif(B_E.WORD similar to '[0-9]+', cast(B_E.WORD as int), 0)
  from RDB$DATABASE
  left join BASE B_NUMBER on B_NUMBER.INDEX_ = 1
  left join BASE B_CODE on B_CODE.INDEX_ = 3
  left join REGISTER R on R.CODE =  iif(B_CODE.WORD similar to '[0-9]+', cast(B_CODE.WORD as int), null)
  left join BASE B_ROW on B_ROW.INDEX_ = 4

  left join BASE B_Y on B_Y.INDEX_ = 5
  left join BASE B_Q1 on B_Q1.INDEX_ = 6
  left join BASE B_Q2 on B_Q2.INDEX_ = 7
  left join BASE B_Q3 on B_Q3.INDEX_ = 8
  left join BASE B_Q4 on B_Q4.INDEX_ = 9
  left join BASE B_E on B_E.INDEX_ = 10

  into :NUMBER, :ID, :ROW, :YEAR_, :Q1, :Q2, :Q3, :Q4, :EXTRA_;

  if (:NUMBER is not null) then
  begin
    RDB$SET_CONTEXT(:CONST_VAR, :CONST_ID, :ID);

    if (:NUMBER = 1) then
      delete
      from CUSTOMER_DEBT;
  end
  else
    if (:ROW = '' and RDB$GET_CONTEXT(:CONST_VAR, :CONST_ID) is not null) then
    begin
      ID = RDB$GET_CONTEXT(:CONST_VAR, :CONST_ID);

      if (:YEAR_ <> 0) then
        insert into CUSTOMER_DEBT (ID_REGISTER, INDEX_, VALUE_)
        values (:ID, 1, :YEAR_);

      insert into CUSTOMER_DEBT (ID_REGISTER, INDEX_, VALUE_)
      select :ID, S.INDEX_ + 1, S.WORD
      from SENTENCE_TO_TABLE(:Q1 || ',' || :Q2 || ',' || :Q3 || ',' || :Q4) S
      where extract(month from cast(current_date as date)) > (S.INDEX_ - 1) * 3 and S.WORD <> 0;

      if (:EXTRA_ <> 0) then
        insert into CUSTOMER_DEBT (ID_REGISTER, INDEX_, VALUE_)
        values (:ID, 6, :EXTRA_);
    end
end^


ALTER PROCEDURE USER$GET_NOSTROY_PACKAGE (
    CODE TID = null,
    UPDATE_RECORD TBOOLEAN = 0)
RETURNS (
    ID_REGISTER TID,
    XML TLONG_DESCRIPTION)
AS
declare variable L_FORM integer;
declare variable ID_PERSON TID;
declare variable POSITION_HEAD TNAME;
declare variable FIO TLONG_NAME;
declare variable D_FORMAT TDATETIME_VARCHAR;
declare variable SUB_XML TLONG_DESCRIPTION;
begin
  D_FORMAT = 'YYYY-MM-DDT00:00:00';

  for select
    R.ID_REGISTER, --

    cast(L_FORM.WORD as int), --/
    P.ID_PERSON,
    coalesce(O.POSITION_HEAD || ' ', ''),
    P.SNAME || ' ' || P.NAME || ' ' || P.PNAME,
  
    '<PACKAGE_MEMBER_FULL_DESCRIPTION xsi:type="xsd:string">' || FULL_NAME.RESULT || '</PACKAGE_MEMBER_FULL_DESCRIPTION>' || -- 
    '<PACKAGE_MEMBER_SHORT_DESCRIPTION xsi:type="xsd:string">' || SHORT_NAME.RESULT || '</PACKAGE_MEMBER_SHORT_DESCRIPTION>' || -- 
    '<PACKAGE_MEMBER_MEMBER_TYPE xsi:type="xsd:integer">' || L_FORM.WORD || '</PACKAGE_MEMBER_MEMBER_TYPE>' || --/
    '<PACKAGE_MEMBER_MEMBER_STATUS xsi:type="xsd:integer">' || iif(R.MEMBER = 1, 1, 2) || '</PACKAGE_MEMBER_MEMBER_STATUS>' || -- 
    '<PACKAGE_MEMBER_ACCORDANCE_STATUS xsi:type="xsd:integer">' || iif(R.CORRECT_MEMBER = 1, 1, 2) || '</PACKAGE_MEMBER_ACCORDANCE_STATUS>' || --  
    '<PACKAGE_MEMBER_REGISTRATION_NUMBER xsi:type="xsd:string">' || R.CODE || '</PACKAGE_MEMBER_REGISTRATION_NUMBER>' || --    
    '<PACKAGE_MEMBER_REGISTRATION_DATE_SRO xsi:type="xsd:dateTime">' || FIRST_DATE.RESULT || '</PACKAGE_MEMBER_REGISTRATION_DATE_SRO>' || --    
    '<PACKAGE_MEMBER_OGRN xsi:type="xsd:string">' || O.OGRN_ || '</PACKAGE_MEMBER_OGRN>' || --/
    '<PACKAGE_MEMBER_INN xsi:type="xsd:string">' || O.INN_ || '</PACKAGE_MEMBER_INN>' || --
    '<PACKAGE_MEMBER_PHONES xsi:type="xsd:string">' || O.PHONE || '</PACKAGE_MEMBER_PHONES>' || -- 
    '<PACKAGE_MEMBER_ADDRESS_POST_INDEX xsi:type="xsd:string">' || O.ADDRESS_INDEX || '</PACKAGE_MEMBER_ADDRESS_POST_INDEX>' || -- ()
    '<PACKAGE_MEMBER_ADDRESS_COUNTRY xsi:type="xsd:string">' || O.ADDRESS_COUNTRY || '</PACKAGE_MEMBER_ADDRESS_COUNTRY>' || -- ()
    '<PACKAGE_MEMBER_ADDRESS_SUBJECT xsi:type="xsd:string">' || REG.CODE || '</PACKAGE_MEMBER_ADDRESS_SUBJECT>' || -- ()
    '<PACKAGE_MEMBER_ADDRESS_DISTRICT xsi:type="xsd:string">' || coalesce(O.ADDRESS_DISTRICT, '') || '</PACKAGE_MEMBER_ADDRESS_DISTRICT>' || -- ()
    '<PACKAGE_MEMBER_ADDRESS_LOCALITY xsi:type="xsd:string">' || coalesce(O.ADDRESS_CITY, '') || '</PACKAGE_MEMBER_ADDRESS_LOCALITY>' || -- ( )
    '<PACKAGE_MEMBER_ADDRESS_STREET xsi:type="xsd:string">' || coalesce(O.ADDRESS_STREET, '') || '</PACKAGE_MEMBER_ADDRESS_STREET>' || -- ()
    '<PACKAGE_MEMBER_ADDRESS_HOME xsi:type="xsd:string">' || coalesce(O.ADDRESS_HOUSE, '') || '</PACKAGE_MEMBER_ADDRESS_HOME>' || -- ()
    '<PACKAGE_MEMBER_ADDRESS_BILDING xsi:type="xsd:string">' || coalesce(O.ADDRESS_STRUCTURE, '') || '</PACKAGE_MEMBER_ADDRESS_BILDING>' || -- (/)
    '<PACKAGE_MEMBER_ADDRESS_ROOM xsi:type="xsd:string">' || coalesce(O.ADDRESS_ROOM, '') || '</PACKAGE_MEMBER_ADDRESS_ROOM>' || -- ()
    '<PACKAGE_MEMBER_EMAIL xsi:type="xsd:string">' || coalesce(O.EMAIL, '') || '</PACKAGE_MEMBER_EMAIL>' || --E-mail
    '<PACKAGE_MEMBER_STATE_REGISTRATION_DATE xsi:type="xsd:dateTime">' || ENTRY_DATE.RESULT || '</PACKAGE_MEMBER_STATE_REGISTRATION_DATE>' ||  --  
    '<PACKAGE_MEMBER_COMPENSATION_FOUND_FEE xsi:type="xsd:double">0</PACKAGE_MEMBER_COMPENSATION_FOUND_FEE>' || -- 
    '<PACKAGE_MEMBER_COMPENSATION_FOUND_FEE_ODO xsi:type="xsd:double">' || coalesce(FC_SUM_.RESULT, '') || '</PACKAGE_MEMBER_COMPENSATION_FOUND_FEE_ODO>' || --    
    '<PACKAGE_MEMBER_RESPONSIBILITY_LEVEL_ODO xsi:type="xsd:string">' || coalesce(LC.NAME, '') || '</PACKAGE_MEMBER_RESPONSIBILITY_LEVEL_ODO>' || --  
    '<PACKAGE_MEMBER_COMPENSATION_FOUND_FEE_VV xsi:type="xsd:double">' || coalesce(FH_SUM_.RESULT, '') || '</PACKAGE_MEMBER_COMPENSATION_FOUND_FEE_VV>' || --    
    '<PACKAGE_MEMBER_RESPONSIBILITY_LEVEL_VV xsi:type="xsd:string">' || coalesce(LH.NAME, '') || '</PACKAGE_MEMBER_RESPONSIBILITY_LEVEL_VV>' || --  
    '<PACKAGE_MEMBER_SUSPENSION_DATE xsi:type="xsd:dateTime">' || coalesce(FINISH_DATE.RESULT, '') || '</PACKAGE_MEMBER_SUSPENSION_DATE>' || --  
    '<PACKAGE_MEMBER_SUSPENSION_REASON xsi:type="xsd:string">' || FINISH_TEXT.RESULT || '</PACKAGE_MEMBER_SUSPENSION_REASON>' --  
  
  from REGISTER R
  left join ORGANIZATION_ O on O.ID_ORGANIZATION_ = R.ID_ORGANIZATION_
  left join LEGAL_FORM LF on LF.ID_LEGAL_FORM = O.ID_LEGAL_FORM
  left join SENTENCE_TO_TABLE('1,2') L_FORM on L_FORM.WORD = iif(LF.SHORT_NAME = '', 2, 1)
  left join PERSON P on P.ID_PERSON = O.ID_PERSON
  left join CONFIG C on 0=0
  left join REGION REG on REG.ID_REGION = O.ID_REGION
  left join FIRST_PROTOCOL FP on FP.ID_REGISTER = R.ID_REGISTER
  left join FUND_SUM_HARM FH on FH.ID_FUND_SUM_HARM = R.ID_FUND_SUM_HARM
  left join FUND_SUM_CONTRACT FC on FC.ID_FUND_SUM_CONTRACT = R.ID_FUND_SUM_CONTRACT
  left join LEVEL_HARM LH on LH.ID_LEVEL_HARM = R.ID_FUND_LEVEL_HARM
  left join LEVEL_CONTRACTOR LC on LC.ID_LEVEL_CONTRACTOR = R.ID_FUND_LEVEL_CONTRACT
  left join STR_TO_XML(LF.LONG_NAME || ' ' || O.NAME) FULL_NAME on 0=0
  left join STR_TO_XML(coalesce(O.SHORT_NAME, '')) SHORT_NAME on 0=0
  left join DATE_TIME_TO_STR(FP.DECISION_DATE, :D_FORMAT) FIRST_DATE on 0=0
  left join FLOAT_TO_STR(FC.SUM_, 0) FC_SUM_ on 0=0
  left join FLOAT_TO_STR(FH.SUM_, 0) FH_SUM_ on 0=0
  left join DATE_TIME_TO_STR(O.ENTRY_DATE, :D_FORMAT) ENTRY_DATE on 0=0
  left join DATE_TIME_TO_STR(iif(R.MEMBER <> 1, R.EXPELLED_DATE, null), :D_FORMAT) FINISH_DATE on 0=0
  left join STR_TO_XML(coalesce(R.BASE_EXCEPTION, '')) FINISH_TEXT on 0=0
  where (:CODE is null) or (R.CODE = :CODE)
  order by R.CODE
  into :ID_REGISTER, :L_FORM, :ID_PERSON, :POSITION_HEAD, :FIO, :XML do
  begin
    XML = '<data xsi:type="soap:data" xmlns:soap="https://lkreestr.nostroy.ru/soap/">' || :XML || '</data>';

-- ui & ip
    if (L_FORM = 2) then
    begin --
      XML = :XML || '<ul xsi:type="soap:ul" xmlns:soap="https://lkreestr.nostroy.ru/soap/"><PACKAGE_MEMBER_DIRECTOR xsi:type="xsd:string"></PACKAGE_MEMBER_DIRECTOR></ul>';

      select 
        '<PACKAGE_MEMBER_INDIVIDUAL_REGISTRATION_ADDRESS xsi:type="xsd:string">' || P.PASS_ARRDESS || '</PACKAGE_MEMBER_INDIVIDUAL_REGISTRATION_ADDRESS>' || --  ( )
        '<PACKAGE_MEMBER_INDIVIDUAL_BIRTH_DAY xsi:type="xsd:dateTime">' || coalesce(P_BIRTH_DATE.RESULT, '') || '</PACKAGE_MEMBER_INDIVIDUAL_BIRTH_DAY>' || --  ( )
        '<PACKAGE_MEMBER_INDIVIDUAL_BIRTH_PLACE xsi:type="xsd:string">' || coalesce(P.BIRTH_PLACE, '') || '</PACKAGE_MEMBER_INDIVIDUAL_BIRTH_PLACE>' || --  ( )
        '<PACKAGE_MEMBER_INDIVIDUAL_PASSPORT xsi:type="xsd:string">' || P.PASS_SERIES ||  ' ' || P.PASS_NUMBER || ', ' || P.PASS_ISSUE || coalesce(' (' || P.PASS_ISSUE_CODE || ') ', '') || P.PASS_DATE || '</PACKAGE_MEMBER_INDIVIDUAL_PASSPORT>' --  ( )
  
      from PERSON P
      left join DATE_TIME_TO_STR(P.BIRTH_DATE, :D_FORMAT) P_BIRTH_DATE on 0=0
      where P.ID_PERSON = :ID_PERSON
      into :SUB_XML;

      XML = :XML || '<ip xsi:type="soap:ip" xmlns:soap="https://lkreestr.nostroy.ru/soap/">' ||
        '<PACKAGE_MEMBER_INDIVIDUAL_FIO xsi:type="xsd:string">' || :FIO || '</PACKAGE_MEMBER_INDIVIDUAL_FIO>' ||
        :SUB_XML || '</ip>';
    end
    else
    begin -- 
      XML = :XML || '<ul xsi:type="soap:ul" xmlns:soap="https://lkreestr.nostroy.ru/soap/"><PACKAGE_MEMBER_DIRECTOR xsi:type="xsd:string">' || :POSITION_HEAD || :FIO || '</PACKAGE_MEMBER_DIRECTOR></ul>' ||
        '<ip xsi:type="soap:ip" xmlns:soap="https://lkreestr.nostroy.ru/soap/">' ||
        '<PACKAGE_MEMBER_INDIVIDUAL_FIO xsi:type="xsd:string"></PACKAGE_MEMBER_INDIVIDUAL_FIO>' ||
        '<PACKAGE_MEMBER_INDIVIDUAL_REGISTRATION_ADDRESS xsi:type="xsd:string"></PACKAGE_MEMBER_INDIVIDUAL_REGISTRATION_ADDRESS>' || --  ( )
        '<PACKAGE_MEMBER_INDIVIDUAL_BIRTH_DAY xsi:type="xsd:dateTime"></PACKAGE_MEMBER_INDIVIDUAL_BIRTH_DAY>' || --  ( )
        '<PACKAGE_MEMBER_INDIVIDUAL_BIRTH_PLACE xsi:type="xsd:string"></PACKAGE_MEMBER_INDIVIDUAL_BIRTH_PLACE>' || --  ( )
        '<PACKAGE_MEMBER_INDIVIDUAL_PASSPORT xsi:type="xsd:string"></PACKAGE_MEMBER_INDIVIDUAL_PASSPORT>' ||--  ( )
        '</ip>';
    end

-- rights
    SUB_XML = null;

    with
      DICT as (
        select '   ' as TEXT
        from rdb$database
      ),
    
      FIRST_PROTOCOL_CONTRACT as (
        select R_.ID_REGISTER, min(P_.ID_PROTOCOL) as ID_PROTOCOL
        from REGISTER R_
        left join RIGHT_ R on R.ID_REGISTER = R_.ID_REGISTER
        left join PROTOCOL P_ on P_.ID_PROTOCOL = R.ID_PROTOCOL_CONTRACT
        group by R_.ID_REGISTER
      ),
    
      BASE as (
        select
          RG.ID_REGISTER,
          LR.ID_APPLICATION_STATUS,
          FPP.ID_PROTOCOL as ID_FIRST_PROTOCOL,
          LR.ID_PROTOCOL as ID_LAST_PROTOCOL,
          FPCP.ID_PROTOCOL as ID_FIRST_PROTOCOL_CONTRACT,
          LR.ID_PERILOUS
        from REGISTER RG
        left join RIGHT_ LR on LR.ID_RIGHT = RG.ID_RIGHT
        left join FIRST_RIGHT FP on FP.ID_REGISTER = RG.ID_REGISTER
        left join PROTOCOL FPP on FPP.ID_PROTOCOL = FP.ID_PROTOCOL
        left join FIRST_PROTOCOL_CONTRACT FPC on FPC.ID_REGISTER = RG.ID_REGISTER
        left join PROTOCOL FPCP on FPCP.ID_PROTOCOL = FPC.ID_PROTOCOL
        where RG.ID_RIGHT is not null
      )
    
    select
      '<status xsi:type="xsd:integer">' || AS_.CODE || '</status>' || -- 
      '<basis xsi:type="xsd:string">' || DT.TEXT || P.NUMBER || '</basis>' || --/
      '<issue_date xsi:type="xsd:dateTime">' || ISSUE_DATE.RESULT || '</issue_date>' || --
      '<is_simple xsi:type="xsd:boolean">' || trim(iif(mod(PR.INDEX_, 10) >= 1, 'true', 'false')) || '</is_simple>' || --  
      '<is_extremely_dangerous xsi:type="xsd:boolean">' || trim(iif(mod(PR.INDEX_, 10) >= 2, 'true', 'false')) || '</is_extremely_dangerous>' || ---,     
      '<is_nuclear xsi:type="xsd:boolean">' || trim(iif(mod(PR.INDEX_, 10) = 3, 'true', 'false')) || '</is_nuclear>' || --   
      '<is_odo xsi:type="xsd:boolean">' || trim(iif(B.ID_FIRST_PROTOCOL_CONTRACT is not null, 'true', 'false')) || '</is_odo>' || --   
      '<odo_date xsi:type="xsd:dateTime">' || coalesce(ODO_DATE.RESULT, '') || '</odo_date>' || --    
      '<odo_basic xsi:type="xsd:string">' || coalesce(DT.TEXT || PC.NUMBER, '') || '</odo_basic>' -- 
    from BASE B
    left join APPLICATION_STATUS AS_ on AS_.ID_APPLICATION_STATUS = B.ID_APPLICATION_STATUS
    left join PROTOCOL P on P.ID_PROTOCOL = B.ID_FIRST_PROTOCOL
    left join PERILOUS PR on PR.ID_PERILOUS = B.ID_PERILOUS
    left join PROTOCOL PC on PC.ID_PROTOCOL = B.ID_FIRST_PROTOCOL_CONTRACT
    left join DATE_TIME_TO_STR(P.DECISION_DATE, :D_FORMAT) ISSUE_DATE on 0=0
    left join DATE_TIME_TO_STR(PC.DECISION_DATE, :D_FORMAT) ODO_DATE on 0=0
    left join DICT DT on 0=0
    where B.ID_REGISTER = :ID_REGISTER
    into :SUB_XML;

    if (SUB_XML is null) then
      XML = :XML || '<rights xsi:type="soap:rights" xmlns:soap="https://lkreestr.nostroy.ru/soap/" />';
    else
      XML = :XML || '<rights xsi:type="soap:rights" xmlns:soap="https://lkreestr.nostroy.ru/soap/" >' || :SUB_XML || '</rights>';

-- right_suspensions
    SUB_XML = null;

    with
      DICT as (
        select 1000000 as INC, '   ' as TEXT
        from rdb$database
      ),
    
      RESULT as (
        select I.ID_INTERVENTION, I.ID_REGISTER, M.TYPE_, I.DATE_, DE.DESCRIPTION || ' ' || I.NUMBER as NUMBER
        from INTERVENTION I
        left join DEPARTMENT DE on DE.ID_DEPARTMENT = I.ID_DEPARTMENT
        left join MEASURE M on M.ID_MEASURE = I.ID_MEASURE
        left join DICT D on 0=0
        where M.TYPE_ <> 0 and I.DATE_ > '30.06.2017'
        
        union all
    
        select D.INC + RG.ID_RIGHT, RG.ID_REGISTER, 4, RG.EXPELLED_DATE, D.TEXT || RG.EXPELLED_NUMBER
        from REGISTER RG
        left join DICT D on 0=0
        where RG.MEMBER = 0
          and RG.ID_RIGHT is not null
      )
    
    select list('<right_suspension xsi:type="soap:right_suspension">' ||
      '<suspension_decision xsi:type="xsd:integer">' || R.TYPE_ || '</suspension_decision>' ||
      '<basis xsi:type="xsd:string">' || R.NUMBER || '</basis>' ||
      '<basis_date xsi:type="xsd:dateTime">' || R.DATE_ || '</basis_date>' ||
      '</right_suspension>', '')
    from RESULT R
    left join DATE_TIME_TO_STR( R.DATE_, :D_FORMAT) BASIS_DATE on 0=0
    where R.ID_REGISTER = :ID_REGISTER
    into :SUB_XML;

    if (coalesce(SUB_XML, '') = '') then
      XML = :XML || '<soap:right_suspensions xsi:type="soapenc:Array" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" />';
    else
      XML = :XML || '<soap:right_suspensions xsi:type="soapenc:Array" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" >' || :SUB_XML || '</soap:right_suspensions>';

-- insurances
    SUB_XML = null;

    select list('<insurance xsi:type="soap:insurance">' ||
      '<type xsi:type="xsd:string">1</type>' || --  /
      '<object xsi:type="xsd:string">' || coalesce(IS_.CODE, '') || '</object>' || --  
      '<contractnumber xsi:type="xsd:string">' || coalesce(OI.DOC_NUMBER, '') || '</contractnumber>' || --   ()
      '<begindate xsi:type="xsd:dateTime">' || BEGIN_DATE.RESULT || '</begindate>' || --  
      '<enddate xsi:type="xsd:dateTime">' || END_DATE.RESULT || '</enddate>' || --  
      '<insurancesumm xsi:type="xsd:double">' || SUMM.RESULT || '</insurancesumm>' || --  
      '<insurer xsi:type="xsd:string">' || NAME.RESULT || '</insurer>' || -- 
      '<license xsi:type="xsd:string">' || I.NUMBER || '</license>' || --
      '<place xsi:type="xsd:string">' || coalesce(PLACE.RESULT, '') || '</place>' || --
      '<phone xsi:type="xsd:string">' || coalesce(I.PHONE, '') || '</phone>' || -- 
      '</insurance>', '')
    from REGISTER R
    left join ORGANIZATION_INSURANCE OI on OI.ID_ORGANIZATION_ = R.ID_ORGANIZATION_
    left join INSURANCE I on I.ID_INSURANCE = OI.ID_INSURANCE
    left join INSURANCE_SUBJECT IS_ on IS_.ID_INSURANCE_SUBJECT = OI.ID_INSURANCE_SUBJECT
    left join DATE_TIME_TO_STR(OI.PERIOD_DATE_START, :D_FORMAT) BEGIN_DATE on 0=0
    left join DATE_TIME_TO_STR(OI.PERIOD_DATE_FINISH, :D_FORMAT) END_DATE on 0=0
    left join FLOAT_TO_STR(OI.SUM_, 0) SUMM on 0=0
    left join STR_TO_XML(I.NAME) NAME on 0=0
    left join STR_TO_XML(I.ADDRESS) PLACE on 0=0
    where R.ID_REGISTER = :ID_REGISTER
    into :SUB_XML;

    if (coalesce(SUB_XML, '') = '') then
      XML = :XML || '<soap:insurances xsi:type="soapenc:Array" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" />';
    else
      XML = :XML || '<soap:insurances xsi:type="soapenc:Array" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" >' || :SUB_XML || '</soap:insurances>';

-- checks
    SUB_XML = null;

    select list('<check xsi:type="soap:check">' ||
      '<member_check_type xsi:type="xsd:integer">' || C.INDEX_ || '</member_check_type>' || -- 
      '<member_check_result xsi:type="xsd:integer">' || (CR.IS_VIOLATIONS + 1) || '</member_check_result>' || -- 
      '<disciplinary_action xsi:type="xsd:integer">' || (2 - RC.IS_INTERVENTION) || '</disciplinary_action>' || --  
      '<checkdate xsi:type="xsd:dateTime">' || CHECK_DATE.RESULT || '</checkdate>' || -- 
      '</check>', '')
    from REGISTER R
    join REGISTER_CHECK RC on RC.ID_REGISTER = R.ID_REGISTER
    left join CHECK_RESULT CR on CR.ID_CHECK_RESULT = RC.ID_CHECK_RESULT
    left join TYPE_CHECK TC on TC.ID_TYPE_CHECK = RC.ID_TYPE_CHECK
    left join SENTENCE_TO_TABLE(',') C on C.WORD = TC.NAME
    left join DATE_TIME_TO_STR(RC.DATE_, :D_FORMAT) CHECK_DATE on 0=0
    where R.ID_REGISTER = :ID_REGISTER
    into :SUB_XML;

    if (coalesce(SUB_XML, '') = '') then
      XML = :XML || '<soap:checks xsi:type="soapenc:Array" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" />';
    else
      XML = :XML || '<soap:checks xsi:type="soapenc:Array" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" >' || :SUB_XML || '</soap:checks>';

-- specialists

    suspend;

    if (UPDATE_RECORD = 1) then
      update REGISTER R set
        R.NOSTROY_HASH_ = hash(:XML),
        R.DID_SEND_TO_NOSTROY = 1
      where R.ID_REGISTER = :ID_REGISTER;
  end
end^


ALTER PROCEDURE USER$REFRESH_NOSTROY_STATUS
RETURNS (
    ID_REGISTER TID,
    CODE TID,
    NAME TSHORT_DESCRIPTION)
AS
begin
  for select R.ID_REGISTER, R.CODE, S.RESULT
  from USER$GET_NOSTROY_PACKAGE N
  left join REGISTER R on R.ID_REGISTER = N.ID_REGISTER
  left join ORGANIZATION_ O on O.ID_ORGANIZATION_ = R.ID_ORGANIZATION_
  left join STR_TO_XML(O.NAME) S on 0=0
  where R.NOSTROY_HASH_ <> hash(N.XML)
  into :ID_REGISTER, :CODE, :NAME do
  begin
    update REGISTER R_ set
      R_.DID_SEND_TO_NOSTROY = 0
    where R_.ID_REGISTER = :ID_REGISTER;

    suspend;
  end
end^



SET TERM ; ^
